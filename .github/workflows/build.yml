
name: Viral Video Automation

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  video-editor:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    # 1. Setup Environment
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Set up Python 3.10
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install System Deps
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg curl

    # 2. Install Python Libraries
    - name: Install Python Packages
      run: |
        pip install yt-dlp faster-whisper numpy openai tqdm torch

    # 3. Generate & Run Script
    - name: Run Video Editor
      run: |
        cat << 'EOF' > main.py
        import os, sys, subprocess, json, time, re
        from pathlib import Path

        print("=" * 60)
        print("VIRAL VIDEO EDITOR - GITHUB ACTIONS VERSION")
        print("=" * 60)

        import torch
        from openai import OpenAI
        from tqdm import tqdm
        import numpy as np

        # ----------------------------
        # CONFIGURATION
        # ----------------------------
        # URL SESUAI PERMINTAAN ANDA
        VIDEO_URL = "https://api.vidssave.com/api/contentsite_api/media/download_redirect?request=sgRpmKL3iNBpyIDr4IgGHBXJiSxcf0EYQuGexs_6KdEalT5ycrs3ffYBEZXevrdUBcrNn6iDw8MfLNTFhlNy7biCIOWf4sDWWBA_S3Gc0ACg1ZPIBzwNN6iyUU-0-PuEErnV6vklMuUiHCyNARF0XKYdjAEXIFyrKF3ytFZL3SURwBQ6zqTIxoinSGmbNRzuDj7GLLN2-qE4j55wtrmuN0sRuMHC3v3eqf14UHFW6OQMmpQ5sIwzvVB6Y5OhROhLgjaA0g8XRTd1z8-rT37YaXo2Y1N59CFMiBNLYoMKlQY-ogHXajXJ3IPsDSTl679jtoOgZpQQY4lq8X-k8lRdgZ5x16iwKPU9AC5d20FwHAFwPaA6sqqj6Sulox0JtTHVQT3xcaUUJowztbrK3N1wClY_bp0pTnhFn4ntpiJhobshFeQwTW0cvTh7u-DnwrB6zF3N3uAfdG9YkBFZZfMIps_fqAN_JZe1TE8Xy6dOcm1cAkp4CQA-6VSb2h75I3aACfjLy872k1vGM7UyG_aS1MqWJUICirs_GRhll-ZswtvtiONJHwWROte6JB-8vU4YEOzzqQAnMb6vwwKFoFArv6XjRP9hX__3UF6yn8R7YYtp9bMuc53-ovjN9sdZoX02"
        
        
        API_KEY = "Kontolondon" 
        API_BASE = "https://tes-coral.vercel.app/v1/"
        WHISPER_MODEL_NAME = "medium"

        # --- SETUP DIRECTORIES ---
        BASE_DIR = Path.cwd()
        OUTPUT_DIR = BASE_DIR / "output"
        MODELS_DIR = BASE_DIR / "models"
        
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
        MODELS_DIR.mkdir(parents=True, exist_ok=True)

        AUDIO_PATH = BASE_DIR / "audio.wav"
        VIDEO_PATH = BASE_DIR / "video.mp4"
        ZIP_OUTPUT_PATH = BASE_DIR / "viral_segments.zip"

        print(f"ðŸ“‚ Working Directory: {BASE_DIR}")
        print(f"ðŸ“‚ Output Directory: {OUTPUT_DIR}")

        # ----------------------------
        # INITIALIZE OPENAI CLIENT
        # ----------------------------
        try:
            openai_client = OpenAI(api_key=API_KEY, base_url=API_BASE)
            print("âœ… OpenAI client initialized")
        except Exception as e:
            print(f"âŒ Failed to initialize OpenAI client: {e}")
            sys.exit(1)

        # ----------------------------
        # UTILITY FUNCTIONS
        # ----------------------------
        def smart_download(url: str, output_path: Path):
            """Download video with fallback mechanism (yt-dlp -> curl)"""
            print(f"\nðŸ“¥ DOWNLOADING VIDEO")
            print(f"   Target: {url[:60]}...")
            
            # METHOD 1: Try yt-dlp first
            print("   ðŸ‘‰ Attempt 1: Using yt-dlp...")
            try:
                cmd = [
                    "yt-dlp",
                    "-o", str(output_path),
                    "--quiet", "--no-warnings",
                    "--no-check-certificate",
                    url
                ]
                subprocess.run(cmd, check=True, timeout=300)
                if output_path.exists() and output_path.stat().st_size > 1000:
                    print(f"   âœ… Download successful via yt-dlp")
                    return output_path
            except Exception as e:
                print(f"   âš ï¸ yt-dlp failed: {e}")

            # METHOD 2: Fallback to curl (Direct Download)
            print("   ðŸ‘‰ Attempt 2: Using curl (Direct Link Fallback)...")
            try:
                # User-Agent palsu agar tidak diblokir server
                user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
                cmd = [
                    "curl", "-L", 
                    "-A", user_agent,
                    "-o", str(output_path),
                    url
                ]
                subprocess.run(cmd, check=True, timeout=600)
                
                if output_path.exists() and output_path.stat().st_size > 1000:
                    size_mb = output_path.stat().st_size / (1024 * 1024)
                    print(f"   âœ… Download successful via curl: {size_mb:.2f} MB")
                    return output_path
                else:
                    raise FileNotFoundError("File is empty or not found after curl")
            except Exception as e:
                print(f"   âŒ All download methods failed: {str(e)}")
                raise Exception("Could not download video. The link might be expired (410 Gone).")

        def convert_video_to_audio(video_path: Path, audio_path: Path) -> Path:
            """Convert to WAV"""
            print(f"\nðŸ”„ CONVERTING VIDEO TO AUDIO")
            if not video_path.exists():
                raise FileNotFoundError(f"Video file not found at {video_path}")
                
            cmd = [
                "ffmpeg", "-i", str(video_path), "-vn",
                "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1",
                "-y", str(audio_path)
            ]
            subprocess.run(cmd, check=True, stderr=subprocess.DEVNULL)
            print(f"   âœ… Audio ready: {audio_path.name}")
            return audio_path

        def get_video_duration(path: Path) -> float:
            try:
                cmd = ["ffprobe", "-v", "error", "-show_entries", "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", str(path)]
                return float(subprocess.check_output(cmd).decode().strip())
            except: return 0

        # ----------------------------
        # TRANSCRIPTION
        # ----------------------------
        class FasterWhisperTranscriber:
            def __init__(self, model_name):
                self.model_name = model_name
                self.model = None
            
            def load_model(self):
                print(f"\nðŸ“¥ LOADING MODEL (Download to {MODELS_DIR})")
                from faster_whisper import WhisperModel
                self.model = WhisperModel(
                    self.model_name,
                    device="cpu",
                    compute_type="int8",
                    download_root=str(MODELS_DIR)
                )
                return self.model
            
            def transcribe(self, audio_path):
                if not self.model: self.load_model()
                print(f"\nðŸŽ™ï¸ TRANSCRIBING...")
                segments_generator, info = self.model.transcribe(str(audio_path), beam_size=5)
                
                all_segments = []
                full_text = ""
                for segment in segments_generator:
                    all_segments.append({
                        "start": segment.start, "end": segment.end, "text": segment.text.strip()
                    })
                    full_text += segment.text.strip() + " "
                
                return {
                    "text": full_text.strip(),
                    "segments": all_segments,
                    "language": info.language
                }

        # ----------------------------
        # GPT-4 EDITOR
        # ----------------------------
        class GPT4VideoEditor:
            def __init__(self, client, video_path, transcript_data):
                self.client = client
                self.video_path = video_path
                self.transcript = transcript_data
                self.duration = get_video_duration(video_path)
            
            def analyze(self):
                print(f"\nðŸ§  ANALYZING WITH GPT-4")
                segments = self.transcript.get("segments", [])
                transcript_text = ""
                for seg in segments[:50]:
                    transcript_text += f"[{seg['start']:.1f}s - {seg['end']:.1f}s]: {seg['text']}\\n"
                
                system_prompt = "You are a viral video editor. Create segments UNDER 60 SECONDS based on the transcript. Return ONLY a JSON array with objects containing: start_time, end_time, title, hook, target_platform."
                user_prompt = f"Video Duration: {self.duration}s. Analyze this transcript and find viral moments. Transcript:\\n{transcript_text}\\n\\nReturn JSON array only."

                try:
                    response = self.client.chat.completions.create(
                        model="gpt-4",
                        messages=[{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}],
                        temperature=0.7
                    )
                    return response.choices[0].message.content.strip()
                except Exception as e:
                    print(f"âŒ GPT Error: {e}")
                    return None

            def parse(self, gpt_response):
                try:
                    match = re.search(r'\[.*\]', gpt_response.strip(), re.DOTALL)
                    if not match: return []
                    data = json.loads(match.group(0))
                    
                    valid = []
                    for i, item in enumerate(data, 1):
                        start, end = float(item['start_time']), float(item['end_time'])
                        if (end - start) > 60: end = start + 60
                        item['index'] = i
                        item['start_time'] = start
                        item['end_time'] = end
                        item['duration'] = end - start
                        valid.append(item)
                    return valid
                except Exception as e:
                    print(f"âŒ Parse Error: {e}")
                    return []

        # ----------------------------
        # CUTTER
        # ----------------------------
        def cut_video(video_path, segments, output_dir):
            print(f"\nâœ‚ï¸ CUTTING {len(segments)} SEGMENTS")
            results = []
            for seg in segments:
                safe_title = re.sub(r'[^\w\s-]', '', seg['title']).strip().replace(" ", "_")[:30]
                out_name = output_dir / f"seg_{seg['index']:02d}_{safe_title}.mp4"
                
                cmd = [
                    "ffmpeg", "-y", "-i", str(video_path),
                    "-ss", str(seg['start_time']), "-to", str(seg['end_time']),
                    "-c:v", "libx264", "-c:a", "aac",
                    "-vf", "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2:color=black",
                    str(out_name)
                ]
                subprocess.run(cmd, check=False, stderr=subprocess.DEVNULL)
                if out_name.exists():
                    print(f"   âœ… Saved: {out_name.name}")
                    results.append(out_name)
            return results

        # ----------------------------
        # MAIN
        # ----------------------------
        def main():
            # 1. Smart Download (try yt-dlp -> then curl)
            if not VIDEO_PATH.exists():
                smart_download(VIDEO_URL, VIDEO_PATH)
            
            # 2. Audio
            convert_video_to_audio(VIDEO_PATH, AUDIO_PATH)
            
            # 3. Transcribe
            transcriber = FasterWhisperTranscriber(WHISPER_MODEL_NAME)
            res = transcriber.transcribe(AUDIO_PATH)
            
            # 4. Analyze
            editor = GPT4VideoEditor(openai_client, VIDEO_PATH, res)
            gpt_res = editor.analyze()
            if not gpt_res: return
            
            segments = editor.parse(gpt_res)
            print(f"   found {len(segments)} valid segments")

            # 5. Cut
            files = cut_video(VIDEO_PATH, segments, OUTPUT_DIR)
            
            # 6. Zip
            if files:
                import zipfile
                print(f"\nðŸ“¦ Zipping results to {ZIP_OUTPUT_PATH}...")
                with zipfile.ZipFile(ZIP_OUTPUT_PATH, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for f in files:
                        zipf.write(f, f.name)
                print("âœ… Zip created successfully")

        if __name__ == "__main__":
            main()
        EOF
        
        # Jalankan Script
        python main.py

    # 4. Upload Hasil Output (Zip File)
    - name: Upload Viral Segments Zip
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: viral-video-results
        path: viral_segments.zip
        retention-days: 5
