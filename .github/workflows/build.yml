name: ðŸŽ¬ AI Director Ultra (Fixed Video Playback)

on:
  workflow_dispatch:
    inputs:
      video_url:
        description: 'URL Video MP4/YouTube'
        required: true
        default: 'https://api.vidssave.com/api/contentsite_api/media/download_redirect?request=sgRpmKL3iNBpyIDr4IgGHBXJiSxcf0EYQuGexs_6KdEalT5ycrs3ffYBEZXevrdUBcrNn6iDw8MfLNTFhlNy7biCIOWf4sDWWBA_S3Gc0ACg1ZPIBzwNN6iyUU-0-PuEErnV6vklMuUiHCyNARF0XKYdjAEXIFyrKF3ytFZL3SURwBQ6zqTIxoinSGmbNRzuDj7GLLN2-qE4j55wtrmuN0sRuMHC3v3eqf14UHFW6OQMmpQ5sIwzvVB6Y5OhROhLgjaA0g8XRTd1z8-rT37YaXo2Y1N59CFMiBNLYoMKlQY-ogHXajXJ3IPsDSTl679jtoOgZpQQY4lq8X-k8lRdgZ5x16iwKPU9AC5d20FwHAFwPaA6sqqj6Sulox0JtTHVQT3xcaUUJowztbrK3N1wClY_bp0pTnhFn4ntpiJhobshFeQwTW0cvTh7u-DnwrB6zF3N3uAfdG9YkBFZZfMIps_fqAN_JZe1TE8Xy6dOcm1cAkp4CQA-6VSb2h75I3aACfjLy872k1vGM7UyG_aS1MqWJUICirs_GRhll-ZswtvtiONJHwWROte6JB-8vU4YEOzzqQAnMb6vwwKFoFArv6XjRP9hX__3UF6yn8R7YYtp9bMuc53-ovjN9sdZoX02'
      num_shorts:
        description: 'Target Jumlah Klip'
        required: false
        default: '3'
      platform:
        description: 'Platform Target'
        required: false
        default: 'tiktok'
        type: choice
        options:
          - tiktok
          - youtube_shorts
          - instagram_reels
          - all
      quality:
        description: 'Kualitas Video'
        required: false
        default: 'balanced'
        type: choice
        options:
          - fast
          - balanced
          - high

jobs:
  ai-director-ultra:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    steps:
      - name: ðŸ“ Setup Workspace
        run: |
          mkdir -p workspace output logs
          
      - name: âš¡ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ðŸ Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: ðŸ”§ Install System Dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y \
            ffmpeg \
            libsm6 \
            libxext6 \
            libgl1 \
            git \
            wget \
            curl \
            mediainfo
          
      - name: ðŸ“¦ Install Python Packages
        run: |
          python -m pip install --upgrade pip
          
          # Install Whisper
          pip install git+https://github.com/openai/whisper.git
          
          # PyTorch CPU version
          pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu
          
          # Core AI/ML
          pip install openai==0.28.1
          pip install langchain==0.0.346
          
          # Audio/Video Processing
          pip install yt-dlp==2024.4.9
          pip install ffmpeg-python==0.2.0
          
          # Utilities
          pip install numpy==1.26.4
          pip install tiktoken==0.5.2
          pip install tqdm==4.66.1
          pip install requests==2.31.0
          pip install colorama==0.4.6
          pip install tenacity==8.2.3
          
      - name: ðŸš€ Run AI Director Ultra (Fixed Video Encoding)
        env:
          OPENAI_API_KEY: "Kontolondon"
          OPENAI_API_BASE: "https://tes-coral.vercel.app/v1/"
          VIDEO_URL: ${{ github.event.inputs.video_url }}
          NUM_SHORTS: ${{ github.event.inputs.num_shorts || 3 }}
          TARGET_PLATFORM: ${{ github.event.inputs.platform || 'tiktok' }}
          QUALITY_PRESET: ${{ github.event.inputs.quality || 'balanced' }}
        run: |
          cat > ai_director_fixed_video.py << 'EOF'
          import os
          import sys
          import json
          import re
          import subprocess
          import time
          import logging
          from pathlib import Path
          from datetime import datetime
          from typing import List, Dict, Any
          
          import whisper
          import torch
          from tqdm import tqdm
          
          # Setup logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.StreamHandler(),
                  logging.FileHandler('ai_director.log')
              ]
          )
          logger = logging.getLogger(__name__)
          
          # ========== CONFIGURATION ==========
          class Config:
              def __init__(self):
                  self.OPENAI_API_KEY = "Kontolondon"
                  self.OPENAI_API_BASE = "https://tes-coral.vercel.app/v1/"
                  self.GPT_MODEL = "gpt-4"
                  
                  self.VIDEO_URL = os.getenv("VIDEO_URL", "")
                  self.NUM_SHORTS = int(os.getenv("NUM_SHORTS", 3))
                  self.TARGET_PLATFORM = os.getenv("TARGET_PLATFORM", "tiktok")
                  self.QUALITY_PRESET = os.getenv("QUALITY_PRESET", "balanced")
                  
                  self.WORKDIR = Path("workspace")
                  self.OUTDIR = Path("output")
                  
                  self.WORKDIR.mkdir(exist_ok=True)
                  self.OUTDIR.mkdir(exist_ok=True)
                  
                  if not self.VIDEO_URL:
                      raise ValueError("VIDEO_URL is required!")
          
          config = Config()
          
          # ========== VIDEO DOWNLOADER ==========
          class VideoDownloader:
              def __init__(self):
                  self.video_path = config.WORKDIR / "source_video.mp4"
                  
              def download(self) -> Path:
                  """Download video with robust error handling"""
                  logger.info(f"ðŸ“¥ Downloading video from: {config.VIDEO_URL}")
                  
                  # Clean up any existing file
                  if self.video_path.exists():
                      self.video_path.unlink()
                  
                  try:
                      # Try yt-dlp first
                      import yt_dlp
                      
                      ydl_opts = {
                          'format': 'best[ext=mp4]/best[ext=webm]/best',
                          'outtmpl': str(self.video_path.with_suffix('.%(ext)s')),
                          'quiet': True,
                          'no_warnings': True,
                          'extract_flat': False,
                          'http_headers': {
                              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                              'Accept': '*/*',
                              'Accept-Language': 'en-US,en;q=0.9',
                              'Referer': 'https://www.google.com/',
                              'Origin': 'https://vidssave.com'
                          },
                          'socket_timeout': 30,
                          'retries': 3
                      }
                      
                      with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                          ydl.download([config.VIDEO_URL])
                      
                      # Find downloaded file
                      downloaded = None
                      for ext in ['.mp4', '.mkv', '.webm', '.mov', '.avi']:
                          if self.video_path.with_suffix(ext).exists():
                              downloaded = self.video_path.with_suffix(ext)
                              logger.info(f"Found file: {downloaded}")
                              break
                      
                      if not downloaded:
                          raise ValueError("No file downloaded")
                      
                      # Always convert to MP4 with proper encoding
                      logger.info(f"Converting to standard MP4 format...")
                      temp_path = self.video_path.with_name(f"temp_{self.video_path.name}")
                      
                      # Use FFmpeg to re-encode to standard MP4
                      cmd = [
                          'ffmpeg', '-y',
                          '-i', str(downloaded),
                          '-c:v', 'libx264',
                          '-preset', 'fast',
                          '-crf', '23',
                          '-c:a', 'aac',
                          '-b:a', '128k',
                          '-movflags', '+faststart',
                          '-pix_fmt', 'yuv420p',
                          '-f', 'mp4',
                          str(temp_path)
                      ]
                      
                      result = subprocess.run(
                          cmd,
                          capture_output=True,
                          text=True,
                          timeout=300
                      )
                      
                      if result.returncode != 0:
                          logger.error(f"Conversion failed: {result.stderr[:300]}")
                          # Copy as is
                          temp_path = downloaded
                      
                      # Rename to final path
                      temp_path.rename(self.video_path)
                      
                      # Validate
                      if self._validate_video():
                          size_mb = self.video_path.stat().st_size / (1024 * 1024)
                          logger.info(f"âœ… Download successful: {size_mb:.2f} MB")
                          return self.video_path
                      else:
                          raise ValueError("Downloaded file is not a valid video")
                          
                  except Exception as e:
                      logger.error(f"âŒ Download failed: {e}")
                      raise
              
              def _validate_video(self) -> bool:
                  """Validate downloaded video file"""
                  if not self.video_path.exists():
                      return False
                  
                  file_size = self.video_path.stat().st_size
                  if file_size < 1024 * 100:
                      logger.error(f"File too small: {file_size} bytes")
                      return False
                  
                  # Check with ffprobe
                  try:
                      result = subprocess.run([
                          'ffprobe', '-v', 'error',
                          '-select_streams', 'v:0',
                          '-show_entries', 'stream=codec_name,width,height,duration',
                          '-of', 'json',
                          str(self.video_path)
                      ], capture_output=True, text=True, timeout=10)
                      
                      if result.returncode == 0:
                          info = json.loads(result.stdout)
                          if 'streams' in info and info['streams']:
                              stream = info['streams'][0]
                              logger.info(f"Video info: {stream.get('codec_name')}, "
                                        f"{stream.get('width')}x{stream.get('height')}, "
                                        f"Duration: {stream.get('duration')}s")
                              return True
                  except Exception as e:
                      logger.warning(f"FFprobe check failed: {e}")
                  
                  # Basic check
                  return file_size > 1024 * 1024
          
          # ========== AUDIO TRANSCRIBER ==========
          class AudioTranscriber:
              def __init__(self):
                  self.device = "cuda" if torch.cuda.is_available() else "cpu"
                  logger.info(f"Using device: {self.device}")
                  
              def transcribe(self, video_path: Path) -> List[Dict]:
                  """Transcribe audio using Whisper Medium"""
                  logger.info("ðŸŽ¤ Transcribing audio with Whisper Medium...")
                  
                  try:
                      model = whisper.load_model("medium")
                      
                      result = model.transcribe(
                          str(video_path),
                          fp16=(self.device == "cuda"),
                          verbose=False,
                          language=None,
                          task="transcribe"
                      )
                      
                      segments = []
                      for seg in result.get("segments", []):
                          segments.append({
                              'start': float(seg['start']),
                              'end': float(seg['end']),
                              'text': seg['text'].strip(),
                              'duration': float(seg['end'] - seg['start'])
                          })
                      
                      logger.info(f"âœ… Transcription complete: {len(segments)} segments")
                      return segments
                      
                  except Exception as e:
                      logger.error(f"âŒ Transcription failed: {e}")
                      raise
          
          # ========== AI ANALYZER ==========
          class AIAnalyzer:
              def __init__(self):
                  self.api_key = config.OPENAI_API_KEY
                  self.api_base = config.OPENAI_API_BASE
                  
              def analyze_segments(self, segments: List[Dict]) -> List[Dict]:
                  """Analyze segments using GPT-4 API directly"""
                  logger.info("ðŸ§  Analyzing content with GPT-4...")
                  
                  # Prepare transcript
                  transcript = self._prepare_transcript(segments)
                  
                  # Create prompt
                  prompt = f"""
                  Anda adalah AI Director yang ahli dalam konten viral untuk {config.TARGET_PLATFORM}.
                  
                  TUGAS: Pilih {config.NUM_SHORTS} klip terbaik dari transkrip video.
                  
                  TRANSCRIPT (dengan timestamp):
                  {transcript}
                  
                  KRITERIA:
                  1. HOOK KUAT: 5 detik pertama menarik
                  2. EMOSI TINGGI: Ada emosi kuat
                  3. DURASI IDEAL: 8-30 detik
                  4. CERITA LENGKAP: Ada awal-tengah-akhir
                  5. POTENSI VIRAL: Konten yang dibagikan
                  
                  FORMAT OUTPUT (JSON array):
                  [
                    {{
                      "start_time": 45.2,
                      "end_time": 58.7,
                      "title": "Judul menarik",
                      "viral_score": 92,
                      "reason": "Alasan viral"
                    }}
                  ]
                  
                  Hanya output JSON.
                  """
                  
                  try:
                      import openai
                      
                      openai.api_key = self.api_key
                      openai.api_base = self.api_base
                      
                      response = openai.ChatCompletion.create(
                          model="gpt-4",
                          messages=[
                              {"role": "system", "content": "You are a viral content AI director."},
                              {"role": "user", "content": prompt}
                          ],
                          temperature=0.3,
                          max_tokens=2000
                      )
                      
                      content = response.choices[0].message.content.strip()
                      
                      # Extract JSON
                      json_match = re.search(r'\[.*\]', content, re.DOTALL)
                      if json_match:
                          clips = json.loads(json_match.group())
                      else:
                          clips = json.loads(content)
                      
                      # Validate
                      valid_clips = []
                      for i, clip in enumerate(clips):
                          if self._validate_clip(clip):
                              clip['clip_id'] = f"clip_{i+1:03d}"
                              clip['duration'] = float(clip['end_time']) - float(clip['start_time'])
                              valid_clips.append(clip)
                      
                      logger.info(f"âœ… AI selected {len(valid_clips)} clips")
                      return valid_clips[:config.NUM_SHORTS]
                      
                  except Exception as e:
                      logger.error(f"âŒ AI analysis failed: {e}")
                      return self._generate_fallback_clips(segments)
              
              def _prepare_transcript(self, segments: List[Dict]) -> str:
                  """Prepare transcript for AI analysis"""
                  transcript_lines = []
                  for seg in segments[:40]:
                      start_min = int(seg['start'] // 60)
                      start_sec = int(seg['start'] % 60)
                      text = seg['text'].strip()
                      if text and len(text) > 3:
                          transcript_lines.append(
                              f"[{start_min:02d}:{start_sec:02d}] {text}"
                          )
                  return "\n".join(transcript_lines)
              
              def _validate_clip(self, clip: Dict) -> bool:
                  """Validate clip structure"""
                  required = ['start_time', 'end_time', 'title']
                  for field in required:
                      if field not in clip:
                          return False
                  
                  try:
                      start = float(clip['start_time'])
                      end = float(clip['end_time'])
                      if start >= end or (end - start) < 3:
                          return False
                  except (ValueError, TypeError):
                      return False
                  
                  return True
              
              def _generate_fallback_clips(self, segments: List[Dict]) -> List[Dict]:
                  """Generate fallback clips"""
                  logger.warning("âš ï¸ Using fallback clip generation")
                  
                  clips = []
                  if segments:
                      interval = max(1, len(segments) // config.NUM_SHORTS)
                      for i in range(min(config.NUM_SHORTS, 5)):
                          idx = min(i * interval, len(segments) - 1)
                          seg = segments[idx]
                          start = seg['start']
                          end = min(start + 15, seg['end'] + 3)
                          clips.append({
                              'clip_id': f"fallback_{i+1:03d}",
                              'start_time': start,
                              'end_time': end,
                              'duration': end - start,
                              'title': f"Viral Moment {i+1}",
                              'viral_score': 70
                          })
                  else:
                      for i in range(min(config.NUM_SHORTS, 3)):
                          clips.append({
                              'clip_id': f"default_{i+1:03d}",
                              'start_time': i * 30,
                              'end_time': (i * 30) + 15,
                              'duration': 15,
                              'title': f"Highlight {i+1}",
                              'viral_score': 65
                          })
                  return clips
          
          # ========== VIDEO PRODUCER (FIXED ENCODING) ==========
          class VideoProducer:
              def __init__(self):
                  self.quality_presets = {
                      'fast': {
                          'video_preset': 'ultrafast',
                          'video_crf': '28',
                          'video_bitrate': '1000k',
                          'audio_bitrate': '96k'
                      },
                      'balanced': {
                          'video_preset': 'fast',
                          'video_crf': '23',
                          'video_bitrate': '1500k',
                          'audio_bitrate': '128k'
                      },
                      'high': {
                          'video_preset': 'medium',
                          'video_crf': '20',
                          'video_bitrate': '2000k',
                          'audio_bitrate': '192k'
                      }
                  }
              
              def produce_clips(self, video_path: Path, clips: List[Dict]) -> List[Dict]:
                  """Produce all video clips"""
                  logger.info(f"ðŸŽ¬ Producing {len(clips)} video clips...")
                  
                  produced_clips = []
                  quality = self.quality_presets.get(
                      config.QUALITY_PRESET,
                      self.quality_presets['balanced']
                  )
                  
                  for clip in clips:
                      try:
                          result = self._produce_single_clip(video_path, clip, quality)
                          if result:
                              produced_clips.append(result)
                              logger.info(f"âœ… Created: {result['output_filename']}")
                      except Exception as e:
                          logger.error(f"âŒ Failed clip {clip.get('clip_id')}: {e}")
                  
                  logger.info(f"ðŸŽ‰ Created {len(produced_clips)}/{len(clips)} clips")
                  return produced_clips
              
              def _produce_single_clip(self, video_path: Path, clip: Dict, quality: Dict) -> Dict:
                  """Produce a single video clip with proper encoding"""
                  try:
                      # Create safe filename
                      safe_title = self._sanitize_filename(clip['title'])
                      output_filename = f"{safe_title}_{clip['clip_id']}.mp4"
                      output_path = config.OUTDIR / output_filename
                      
                      # Get parameters
                      start = float(clip['start_time'])
                      duration = float(clip['duration'])
                      
                      # Ensure reasonable duration
                      if duration > 60:
                          duration = 30
                          clip['duration'] = duration
                          clip['end_time'] = start + duration
                      
                      # Build FFmpeg command for PLAYABLE video
                      cmd = [
                          'ffmpeg', '-y',
                          '-ss', str(start),  # Seek to start time
                          '-i', str(video_path),  # Input file
                          '-t', str(duration),  # Duration to extract
                          
                          # VIDEO SETTINGS
                          '-c:v', 'libx264',  # H.264 codec (most compatible)
                          '-preset', quality['video_preset'],  # Encoding speed
                          '-crf', quality['video_crf'],  # Quality (18-28, lower=better)
                          '-b:v', quality['video_bitrate'],  # Bitrate
                          '-maxrate', quality['video_bitrate'],
                          '-bufsize', '2000k',
                          '-pix_fmt', 'yuv420p',  # Color format for compatibility
                          '-profile:v', 'high',  # H.264 profile
                          '-level', '4.0',  # H.264 level
                          '-movflags', '+faststart',  # For web streaming
                          '-g', '30',  # Keyframe interval
                          '-r', '30',  # Frame rate
                          
                          # AUDIO SETTINGS
                          '-c:a', 'aac',  # AAC codec (most compatible)
                          '-b:a', quality['audio_bitrate'],
                          '-ar', '44100',  # Sample rate
                          '-ac', '2',  # Stereo audio
                          
                          # FILTERS
                          '-vf', 'scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,format=yuv420p',
                          
                          # OUTPUT
                          '-f', 'mp4',  # Force MP4 format
                          '-threads', '0',  # Auto threads
                          str(output_path)
                      ]
                      
                      logger.debug(f"FFmpeg command: {' '.join(cmd[:10])}...")
                      
                      # Run FFmpeg
                      result = subprocess.run(
                          cmd,
                          capture_output=True,
                          text=True,
                          timeout=180
                      )
                      
                      if result.returncode != 0:
                          logger.error(f"FFmpeg failed: {result.stderr[:500]}")
                          return None
                      
                      # Verify the output file is playable
                      if not self._verify_video(output_path):
                          logger.error(f"Video verification failed for {output_filename}")
                          
                          # Try alternative simpler encoding
                          logger.info("ðŸ”„ Trying alternative encoding...")
                          alt_result = self._alternative_encoding(video_path, start, duration, output_path)
                          if not alt_result:
                              return None
                      
                      # Get video info
                      video_info = self._get_video_info(output_path)
                      
                      # Update clip metadata
                      clip['output_filename'] = output_filename
                      clip['output_path'] = str(output_path)
                      clip['file_size_mb'] = output_path.stat().st_size / (1024 * 1024)
                      clip['video_info'] = video_info
                      clip['created_at'] = datetime.now().isoformat()
                      
                      # Save metadata
                      metadata_path = output_path.with_suffix('.json')
                      with open(metadata_path, 'w', encoding='utf-8') as f:
                          json.dump(clip, f, indent=2, ensure_ascii=False)
                      
                      return clip
                      
                  except Exception as e:
                      logger.error(f"Clip production error: {e}")
                      return None
              
              def _alternative_encoding(self, video_path: Path, start: float, 
                                      duration: float, output_path: Path) -> bool:
                  """Alternative simple encoding for compatibility"""
                  try:
                      # Simple FFmpeg command - copy codecs if possible
                      cmd = [
                          'ffmpeg', '-y',
                          '-ss', str(start),
                          '-i', str(video_path),
                          '-t', str(duration),
                          '-c:v', 'copy',  # Copy video codec
                          '-c:a', 'copy',  # Copy audio codec
                          '-movflags', '+faststart',
                          str(output_path.with_name(f"temp_{output_path.name}"))
                      ]
                      
                      result = subprocess.run(
                          cmd,
                          capture_output=True,
                          text=True,
                          timeout=120
                      )
                      
                      if result.returncode == 0:
                          temp_path = output_path.with_name(f"temp_{output_path.name}")
                          if temp_path.exists():
                              temp_path.rename(output_path)
                              return True
                      
                      # If copy failed, try basic encoding
                      cmd = [
                          'ffmpeg', '-y',
                          '-ss', str(start),
                          '-i', str(video_path),
                          '-t', str(duration),
                          '-c:v', 'libx264',
                          '-preset', 'fast',
                          '-crf', '23',
                          '-c:a', 'aac',
                          '-b:a', '128k',
                          '-movflags', '+faststart',
                          '-pix_fmt', 'yuv420p',
                          str(output_path)
                      ]
                      
                      result = subprocess.run(
                          cmd,
                          capture_output=True,
                          text=True,
                          timeout=120
                      )
                      
                      return result.returncode == 0
                      
                  except Exception as e:
                      logger.error(f"Alternative encoding failed: {e}")
                      return False
              
              def _verify_video(self, video_path: Path) -> bool:
                  """Verify video is playable"""
                  if not video_path.exists():
                      return False
                  
                  # Check file size
                  if video_path.stat().st_size < 1024 * 10:  # Less than 10KB
                      return False
                  
                  # Use ffprobe to check
                  try:
                      cmd = [
                          'ffprobe', '-v', 'error',
                          '-select_streams', 'v:0',
                          '-count_frames',
                          '-show_entries', 'stream=nb_read_frames',
                          '-of', 'csv=p=0',
                          str(video_path)
                      ]
                      
                      result = subprocess.run(
                          cmd,
                          capture_output=True,
                          text=True,
                          timeout=10
                      )
                      
                      # If ffprobe succeeds, video is likely playable
                      if result.returncode == 0:
                          logger.info(f"âœ… Video verified: {video_path.name}")
                          return True
                      
                  except Exception:
                      pass
                  
                  # Fallback: check file extension and size
                  return video_path.suffix.lower() == '.mp4' and video_path.stat().st_size > 1024 * 100
              
              def _get_video_info(self, video_path: Path) -> Dict:
                  """Get video information"""
                  try:
                      cmd = [
                          'ffprobe', '-v', 'quiet',
                          '-print_format', 'json',
                          '-show_format',
                          '-show_streams',
                          str(video_path)
                      ]
                      
                      result = subprocess.run(
                          cmd,
                          capture_output=True,
                          text=True,
                          timeout=10
                      )
                      
                      if result.returncode == 0:
                          return json.loads(result.stdout)
                  except Exception:
                      pass
                  
                  return {}
              
              def _sanitize_filename(self, filename: str) -> str:
                  """Sanitize filename"""
                  safe = re.sub(r'[<>:"/\\|?*]', '', filename)
                  safe = re.sub(r'\s+', '_', safe)
                  return safe[:40].strip('_')
          
          # ========== REPORT GENERATOR ==========
          class ReportGenerator:
              def generate(self, clips: List[Dict], processing_time: float):
                  """Generate reports"""
                  logger.info("ðŸ“Š Generating production reports...")
                  
                  # Statistics
                  total_duration = sum(c.get('duration', 0) for c in clips)
                  avg_viral_score = sum(c.get('viral_score', 0) for c in clips) / max(len(clips), 1)
                  
                  # JSON Report
                  report = {
                      'summary': {
                          'total_clips': len(clips),
                          'platform': config.TARGET_PLATFORM,
                          'quality': config.QUALITY_PRESET,
                          'processing_time': round(processing_time, 2),
                          'avg_viral_score': round(avg_viral_score, 2),
                          'total_duration': round(total_duration, 2),
                          'generated_at': datetime.now().isoformat()
                      },
                      'clips': []
                  }
                  
                  for clip in clips:
                      report['clips'].append({
                          'clip_id': clip.get('clip_id'),
                          'title': clip.get('title'),
                          'filename': clip.get('output_filename'),
                          'duration': clip.get('duration'),
                          'viral_score': clip.get('viral_score'),
                          'file_size_mb': clip.get('file_size_mb', 0)
                      })
                  
                  # Save JSON
                  json_path = config.OUTDIR / 'report.json'
                  with open(json_path, 'w', encoding='utf-8') as f:
                      json.dump(report, f, indent=2, ensure_ascii=False)
                  
                  # Markdown summary
                  self._generate_markdown(report)
                  
                  logger.info(f"âœ… Reports saved to {json_path}")
              
              def _generate_markdown(self, report: Dict):
                  """Generate markdown summary"""
                  md_path = config.OUTDIR / 'README.md'
                  
                  with open(md_path, 'w', encoding='utf-8') as f:
                      f.write("# ðŸŽ¬ AI Director Ultra - Video Clips\n\n")
                      
                      f.write("## ðŸ“‹ Summary\n")
                      f.write(f"- **Total Clips**: {report['summary']['total_clips']}\n")
                      f.write(f"- **Platform**: {report['summary']['platform']}\n")
                      f.write(f"- **Quality**: {report['summary']['quality']}\n")
                      f.write(f"- **Processing Time**: {report['summary']['processing_time']}s\n")
                      f.write(f"- **Average Viral Score**: {report['summary']['avg_viral_score']}/100\n")
                      f.write(f"- **Total Duration**: {report['summary']['total_duration']}s\n\n")
                      
                      f.write("## ðŸŽ¥ Generated Clips\n\n")
                      f.write("| # | Clip ID | Title | Duration | Viral Score | File Size |\n")
                      f.write("|---|---------|-------|----------|-------------|-----------|\n")
                      
                      for i, clip in enumerate(report['clips'], 1):
                          title = clip['title'][:30] + "..." if len(clip['title']) > 30 else clip['title']
                          f.write(f"| {i} | {clip['clip_id']} | {title} | ")
                          f.write(f"{clip['duration']:.1f}s | {clip['viral_score']} | ")
                          f.write(f"{clip['file_size_mb']:.1f} MB |\n")
                      
                      f.write("\n## ðŸ“ Files\n")
                      f.write("Each clip has two files:\n")
                      f.write("1. `.mp4` - The video file\n")
                      f.write("2. `.json` - Metadata with AI analysis\n")
                      
                      f.write("\n## ðŸš€ How to Use\n")
                      f.write("1. Download the artifacts from GitHub Actions\n")
                      f.write("2. Videos are ready to upload to TikTok/Instagram/YouTube\n")
                      f.write("3. Use the suggested titles and hashtags from metadata\n")
          
          # ========== MAIN EXECUTION ==========
          def main():
              """Main pipeline"""
              start_time = time.time()
              logger.info("ðŸš€ AI DIRECTOR ULTRA - STARTING")
              
              try:
                  # 1. DOWNLOAD
                  logger.info("=" * 50)
                  downloader = VideoDownloader()
                  video_path = downloader.download()
                  
                  # 2. TRANSCRIBE
                  logger.info("=" * 50)
                  transcriber = AudioTranscriber()
                  segments = transcriber.transcribe(video_path)
                  
                  if not segments:
                      logger.error("âŒ No segments transcribed")
                      sys.exit(1)
                  
                  # 3. AI ANALYSIS
                  logger.info("=" * 50)
                  analyzer = AIAnalyzer()
                  clips = analyzer.analyze_segments(segments)
                  
                  if not clips:
                      logger.error("âŒ No clips generated")
                      sys.exit(1)
                  
                  # 4. VIDEO PRODUCTION
                  logger.info("=" * 50)
                  producer = VideoProducer()
                  produced_clips = producer.produce_clips(video_path, clips)
                  
                  if not produced_clips:
                      logger.error("âŒ No clips produced")
                      sys.exit(1)
                  
                  # 5. REPORTS
                  logger.info("=" * 50)
                  processing_time = time.time() - start_time
                  report_gen = ReportGenerator()
                  report_gen.generate(produced_clips, processing_time)
                  
                  # SUCCESS
                  logger.info("=" * 50)
                  logger.info("ðŸŽ‰ SUCCESS!")
                  logger.info(f"ðŸ“ Output: {config.OUTDIR}")
                  logger.info(f"â±ï¸  Time: {processing_time:.1f}s")
                  logger.info(f"ðŸŽ¬ Clips: {len(produced_clips)}")
                  
                  # List files
                  logger.info("ðŸ“„ Generated files:")
                  for ext in ['.mp4', '.json', '.md']:
                      for file in config.OUTDIR.glob(f"*{ext}"):
                          size = file.stat().st_size
                          logger.info(f"   - {file.name} ({size/1024:.1f} KB)")
                  
              except Exception as e:
                  logger.error(f"âŒ FATAL: {e}")
                  import traceback
                  logger.error(traceback.format_exc())
                  sys.exit(1)
          
          if __name__ == "__main__":
              main()
          EOF
          
          echo "ðŸš€ Running AI Director Ultra (Fixed Video Encoding)..."
          python ai_director_fixed_video.py
          
      - name: ðŸ” Verify Video Files
        run: |
          echo "ðŸ” Checking video files..."
          
          if [ -d "output" ]; then
            # Check each video file
            for video in output/*.mp4 2>/dev/null; do
              if [ -f "$video" ]; then
                echo "ðŸ“¹ Checking: $(basename "$video")"
                
                # Get file info
                filesize=$(stat -c%s "$video")
                echo "   Size: $((filesize / 1024)) KB"
                
                # Try to get video info with ffprobe
                if command -v ffprobe >/dev/null 2>&1; then
                  duration=$(ffprobe -v error -show_entries format=duration \
                    -of default=noprint_wrappers=1:nokey=1 "$video" 2>/dev/null || echo "N/A")
                  echo "   Duration: ${duration}s"
                  
                  codec=$(ffprobe -v error -select_streams v:0 \
                    -show_entries stream=codec_name \
                    -of default=noprint_wrappers=1:nokey=1 "$video" 2>/dev/null || echo "N/A")
                  echo "   Codec: $codec"
                fi
                
                echo ""
              fi
            done
            
            # Count files
            mp4_count=$(find output -name "*.mp4" -type f | wc -l)
            json_count=$(find output -name "*.json" -type f | wc -l)
            echo "ðŸ“Š File counts:"
            echo "   MP4 videos: $mp4_count"
            echo "   JSON metadata: $json_count"
          fi
          
      - name: ðŸ“¦ Package Output
        run: |
          if [ -d "output" ] && [ "$(ls -A output/ 2>/dev/null)" ]; then
            echo "ðŸ“¦ Creating archive..."
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            zip -r "videos_$TIMESTAMP.zip" output/
            echo "âœ… Archive created: videos_$TIMESTAMP.zip"
          else
            echo "âš ï¸ No output to package"
            mkdir -p output
            echo "No videos generated - check logs" > output/README.md
          fi
          
      - name: ðŸ“¤ Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ai-video-clips
          path: |
            output/
            videos_*.zip
            ai_director.log
          retention-days: 7
          if-no-files-found: warn
          
      - name: ðŸ“Š Generate Job Summary
        if: always()
        run: |
          if [ -f "output/README.md" ]; then
            cat output/README.md >> $GITHUB_STEP_SUMMARY
          else
            echo "## ðŸŽ¬ AI Director Ultra" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Video production completed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ -f "ai_director.log" ]; then
              echo "### Last status from log:" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              grep -E "(SUCCESS|ERROR|Created|Transcription|Analyzing)" ai_director.log | tail -10 >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "Log empty" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
      - name: ðŸ§¹ Cleanup
        if: always()
        run: |
          rm -rf workspace/ || true
          rm -f ai_director_fixed_video.py || true
