name: ðŸŽ¬ AI Director Ultra (Simple & Working)

on:
  workflow_dispatch:
    inputs:
      video_url:
        description: 'URL Video MP4'
        required: true
        default: 'https://api.vidssave.com/api/contentsite_api/media/download_redirect?request=sgRpmKL3iNBpyIDr4IgGHBXJiSxcf0EYQuGexs_6KdEalT5ycrs3ffYBEZXevrdUBcrNn6iDw8MfLNTFhlNy7biCIOWf4sDWWBA_S3Gc0ACg1ZPIBzwNN6iyUU-0-PuEErnV6vklMuUiHCyNARF0XKYdjAEXIFyrKF3ytFZL3SURwBQ6zqTIxoinSGmbNRzuDj7GLLN2-qE4j55wtrmuN0sRuMHC3v3eqf14UHFW6OQMmpQ5sIwzvVB6Y5OhROhLgjaA0g8XRTd1z8-rT37YaXo2Y1N59CFMiBNLYoMKlQY-ogHXajXJ3IPsDSTl679jtoOgZpQQY4lq8X-k8lRdgZ5x16iwKPU9AC5d20FwHAFwPaA6sqqj6Sulox0JtTHVQT3xcaUUJowztbrK3N1wClY_bp0pTnhFn4ntpiJhobshFeQwTW0cvTh7u-DnwrB6zF3N3uAfdG9YkBFZZfMIps_fqAN_JZe1TE8Xy6dOcm1cAkp4CQA-6VSb2h75I3aACfjLy872k1vGM7UyG_aS1MqWJUICirs_GRhll-ZswtvtiONJHwWROte6JB-8vU4YEOzzqQAnMb6vwwKFoFArv6XjRP9hX__3UF6yn8R7YYtp9bMuc53-ovjN9sdZoX02'
      num_shorts:
        description: 'Target Jumlah Klip'
        required: false
        default: '3'
      platform:
        description: 'Platform Target'
        required: false
        default: 'tiktok'
        type: choice
        options:
          - tiktok
          - youtube_shorts
          - instagram_reels
          - all

jobs:
  ai-director-ultra:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: ðŸ“ Setup Workspace
        run: |
          mkdir -p workspace output logs
          echo "Workspace setup completed"
          
      - name: âš¡ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ðŸ Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: ðŸ”§ Install System Dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y \
            ffmpeg \
            wget \
            curl \
            jq
          echo "System dependencies installed"
          
      - name: ðŸ“¦ Install Python Packages
        run: |
          python -m pip install --upgrade pip
          
          # Install Whisper from GitHub (official)
          pip install git+https://github.com/openai/whisper.git
          
          # Install required packages
          pip install openai==1.12.0
          pip install requests==2.31.0
          pip install numpy==1.26.4
          pip install tiktoken==0.6.0
          pip install tqdm==4.66.2
          pip install colorama==0.4.6
          
          echo "Python packages installed"
          
      - name: ðŸš€ Run AI Director Simple
        env:
          OPENAI_API_KEY: "Kontolondon"
          OPENAI_API_BASE: "https://tes-coral.vercel.app/v1/"
          VIDEO_URL: ${{ github.event.inputs.video_url }}
          NUM_SHORTS: ${{ github.event.inputs.num_shorts || 3 }}
          TARGET_PLATFORM: ${{ github.event.inputs.platform || 'tiktok' }}
        run: |
          cat > ai_director_simple.py << 'EOF'
          import os
          import sys
          import json
          import re
          import subprocess
          import time
          import logging
          from pathlib import Path
          from datetime import datetime
          from typing import List, Dict
          
          import whisper
          import requests
          from tqdm import tqdm
          
          # Setup logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.StreamHandler(),
                  logging.FileHandler('ai_director.log')
              ]
          )
          logger = logging.getLogger(__name__)
          
          # Configuration
          VIDEO_URL = os.getenv("VIDEO_URL", "")
          NUM_SHORTS = int(os.getenv("NUM_SHORTS", 3))
          OPENAI_API_KEY = "Kontolondon"
          OPENAI_API_BASE = "https://tes-coral.vercel.app/v1/"
          
          WORKDIR = Path("workspace")
          OUTDIR = Path("output")
          WORKDIR.mkdir(exist_ok=True)
          OUTDIR.mkdir(exist_ok=True)
          
          # ========== SIMPLE VIDEO DOWNLOAD ==========
          def download_video_simple() -> Path:
              """Simple download using wget"""
              logger.info(f"ðŸ“¥ Downloading video from: {VIDEO_URL}")
              
              video_path = WORKDIR / "source_video.mp4"
              
              # Try wget first (simple and reliable)
              logger.info("ðŸ”„ Trying wget...")
              result = subprocess.run([
                  'wget', '-O', str(video_path),
                  '--timeout=30',
                  '--tries=3',
                  VIDEO_URL
              ], capture_output=True, text=True)
              
              if result.returncode != 0:
                  logger.warning(f"wget failed: {result.stderr[:200]}")
                  
                  # Try curl as fallback
                  logger.info("ðŸ”„ Trying curl...")
                  result = subprocess.run([
                      'curl', '-L', '-o', str(video_path),
                      '--connect-timeout', '30',
                      '--max-time', '300',
                      VIDEO_URL
                  ], capture_output=True, text=True)
              
              if result.returncode != 0:
                  raise Exception(f"Download failed: {result.stderr[:200]}")
              
              # Verify file
              if not video_path.exists():
                  raise Exception("Downloaded file doesn't exist")
              
              file_size = video_path.stat().st_size
              if file_size < 1024 * 1024:  # Less than 1MB
                  raise Exception(f"File too small: {file_size} bytes")
              
              logger.info(f"âœ… Downloaded: {file_size / (1024*1024):.2f} MB")
              
              # Verify it's a valid video file
              try:
                  result = subprocess.run([
                      'ffprobe', '-v', 'error',
                      '-select_streams', 'v:0',
                      '-show_entries', 'stream=codec_name',
                      '-of', 'csv=p=0',
                      str(video_path)
                  ], capture_output=True, text=True, timeout=10)
                  
                  if result.returncode == 0 and 'h264' in result.stdout.lower():
                      logger.info("âœ… Valid H.264 video detected")
                  else:
                      # Convert to H.264 if needed
                      logger.info("ðŸ”„ Converting to H.264 for compatibility...")
                      temp_path = WORKDIR / "converted.mp4"
                      subprocess.run([
                          'ffmpeg', '-i', str(video_path),
                          '-c:v', 'libx264',
                          '-preset', 'fast',
                          '-c:a', 'aac',
                          str(temp_path)
                      ], capture_output=True)
                      temp_path.rename(video_path)
                      
              except Exception as e:
                  logger.warning(f"Video check failed: {e}")
              
              return video_path
          
          # ========== SIMPLE TRANSCRIPTION ==========
          def transcribe_simple(video_path: Path) -> List[Dict]:
              """Simple transcription with Whisper"""
              logger.info("ðŸŽ¤ Transcribing audio...")
              
              try:
                  model = whisper.load_model("medium")
                  
                  result = model.transcribe(
                      str(video_path),
                      fp16=False,  # CPU mode
                      verbose=False,
                      language=None
                  )
                  
                  segments = []
                  for seg in result.get("segments", []):
                      segments.append({
                          'start': float(seg['start']),
                          'end': float(seg['end']),
                          'text': seg['text'].strip(),
                          'duration': float(seg['end'] - seg['start'])
                      })
                  
                  logger.info(f"âœ… Transcription complete: {len(segments)} segments")
                  return segments
                  
              except Exception as e:
                  logger.error(f"âŒ Transcription failed: {e}")
                  raise
          
          # ========== SIMPLE AI ANALYSIS ==========
          def analyze_simple(segments: List[Dict]) -> List[Dict]:
              """Simple analysis with OpenAI API"""
              logger.info("ðŸ§  Analyzing with AI...")
              
              # Prepare transcript (limit to first 30 segments)
              transcript = ""
              for i, seg in enumerate(segments[:30]):
                  start_min = int(seg['start'] // 60)
                  start_sec = int(seg['start'] % 60)
                  transcript += f"[{start_min:02d}:{start_sec:02d}] {seg['text']}\\n"
              
              # Prepare prompt
              prompt = f"""
              Pilih {NUM_SHORTS} klip terbaik dari transkrip video untuk TikTok.
              
              TRANSCRIPT:
              {transcript}
              
              Pilih momen dengan:
              1. Emosi kuat (terkejut, lucu, marah, senang)
              2. Durasi 8-15 detik
              3. Hook yang menarik di 3 detik pertama
              4. Cerita yang lengkap
              
              Format output JSON:
              [
                {{
                  "start_time": 45.2,
                  "end_time": 58.7,
                  "title": "Judul menarik",
                  "reason": "Alasan kenapa viral"
                }}
              ]
              
              Hanya output JSON.
              """
              
              # Call OpenAI API
              try:
                  headers = {
                      'Content-Type': 'application/json',
                      'Authorization': f'Bearer {OPENAI_API_KEY}'
                  }
                  
                  data = {
                      'model': 'gpt-4',
                      'messages': [
                          {'role': 'system', 'content': 'You are a viral content expert.'},
                          {'role': 'user', 'content': prompt}
                      ],
                      'temperature': 0.3,
                      'max_tokens': 2000
                  }
                  
                  response = requests.post(
                      f'{OPENAI_API_BASE}/chat/completions',
                      headers=headers,
                      json=data,
                      timeout=60
                  )
                  
                  if response.status_code != 200:
                      logger.error(f"API Error: {response.status_code} - {response.text}")
                      return generate_fallback_clips(segments)
                  
                  result = response.json()
                  content = result['choices'][0]['message']['content'].strip()
                  
                  # Extract JSON
                  json_match = re.search(r'\[.*\]', content, re.DOTALL)
                  if json_match:
                      clips = json.loads(json_match.group())
                  else:
                      clips = json.loads(content)
                  
                  # Validate clips
                  valid_clips = []
                  for i, clip in enumerate(clips):
                      try:
                          start = float(clip['start_time'])
                          end = float(clip['end_time'])
                          duration = end - start
                          
                          if 5 <= duration <= 30:
                              clip['clip_id'] = f"clip_{i+1:03d}"
                              clip['duration'] = duration
                              valid_clips.append(clip)
                      except (KeyError, ValueError):
                          continue
                  
                  logger.info(f"âœ… Selected {len(valid_clips)} clips")
                  return valid_clips[:NUM_SHORTS]
                  
              except Exception as e:
                  logger.error(f"âŒ AI analysis failed: {e}")
                  return generate_fallback_clips(segments)
          
          def generate_fallback_clips(segments: List[Dict]) -> List[Dict]:
              """Generate simple fallback clips"""
              clips = []
              
              if segments:
                  # Take first few segments
                  for i in range(min(NUM_SHORTS, 5)):
                      if i < len(segments):
                          seg = segments[i]
                          start = seg['start']
                          end = min(start + 15, start + 30)
                          
                          clips.append({
                              'clip_id': f"fallback_{i+1:03d}",
                              'start_time': start,
                              'end_time': end,
                              'duration': end - start,
                              'title': f"Video Moment {i+1}",
                              'reason': 'Auto-selected'
                          })
              else:
                  for i in range(min(NUM_SHORTS, 3)):
                      clips.append({
                          'clip_id': f"default_{i+1:03d}",
                          'start_time': i * 30,
                          'end_time': (i * 30) + 15,
                          'duration': 15,
                          'title': f"Clip {i+1}",
                          'reason': 'Default'
                      })
              
              return clips
          
          # ========== SIMPLE VIDEO CREATION ==========
          def create_videos_simple(video_path: Path, clips: List[Dict]):
              """Create video clips that actually work"""
              logger.info(f"ðŸŽ¬ Creating {len(clips)} video clips...")
              
              created = 0
              for clip in clips:
                  try:
                      # Create safe filename
                      safe_title = re.sub(r'[^\w\s-]', '', clip.get('title', 'clip'))
                      safe_title = re.sub(r'[-\s]+', '_', safe_title)[:30]
                      
                      output_file = OUTDIR / f"{safe_title}_{clip['clip_id']}.mp4"
                      
                      start = float(clip['start_time'])
                      duration = float(clip['duration'])
                      
                      # SIMPLE FFMPEG COMMAND THAT WORKS
                      cmd = [
                          'ffmpeg', '-y',
                          '-ss', str(start),
                          '-i', str(video_path),
                          '-t', str(duration),
                          '-c:v', 'libx264',        # Use H.264 codec
                          '-preset', 'fast',        # Fast encoding
                          '-crf', '23',             # Good quality
                          '-c:a', 'aac',           # AAC audio
                          '-b:a', '128k',          # Audio bitrate
                          '-movflags', '+faststart', # For web playback
                          '-vf', 'scale=1080:1920:force_original_aspect_ratio=increase,pad=1080:1920:(ow-iw)/2:(oh-ih)/2', # Resize for TikTok
                          str(output_file)
                      ]
                      
                      logger.debug(f"Running: {' '.join(cmd)}")
                      
                      result = subprocess.run(
                          cmd,
                          capture_output=True,
                          text=True,
                          timeout=180
                      )
                      
                      if result.returncode == 0:
                          # Verify the output file is playable
                          verify_result = subprocess.run([
                              'ffprobe', '-v', 'error',
                              '-show_format', '-show_streams',
                              str(output_file)
                          ], capture_output=True, text=True)
                          
                          if verify_result.returncode == 0:
                              # Add file info to clip
                              clip['output_file'] = output_file.name
                              clip['file_size_mb'] = output_file.stat().st_size / (1024 * 1024)
                              
                              # Save metadata
                              metadata = {
                                  'clip_info': clip,
                                  'created_at': datetime.now().isoformat(),
                                  'video_info': json.loads(verify_result.stdout) if verify_result.stdout else {}
                              }
                              
                              with open(output_file.with_suffix('.json'), 'w') as f:
                                  json.dump(metadata, f, indent=2)
                              
                              logger.info(f"âœ… Created: {output_file.name} ({clip['file_size_mb']:.1f} MB)")
                              created += 1
                          else:
                              logger.error(f"âŒ Output file not playable: {verify_result.stderr[:200]}")
                              if output_file.exists():
                                  output_file.unlink()
                      else:
                          logger.error(f"âŒ FFmpeg failed: {result.stderr[:200]}")
                          
                  except Exception as e:
                      logger.error(f"âŒ Failed to create clip: {e}")
              
              logger.info(f"ðŸŽ‰ Successfully created {created}/{len(clips)} clips")
              return created
          
          # ========== MAIN FUNCTION ==========
          def main():
              """Main execution"""
              logger.info("ðŸš€ AI Director - Starting...")
              start_time = time.time()
              
              try:
                  # 1. Download video
                  video_path = download_video_simple()
                  
                  # 2. Transcribe
                  segments = transcribe_simple(video_path)
                  
                  if not segments:
                      logger.error("No segments found")
                      return
                  
                  # 3. AI analysis
                  clips = analyze_simple(segments)
                  
                  if not clips:
                      logger.error("No clips selected")
                      return
                  
                  # 4. Create videos
                  created = create_videos_simple(video_path, clips)
                  
                  # 5. Generate summary
                  total_time = time.time() - start_time
                  
                  summary = {
                      'total_clips_attempted': len(clips),
                      'total_clips_created': created,
                      'total_time_seconds': round(total_time, 2),
                      'video_source': VIDEO_URL,
                      'created_at': datetime.now().isoformat()
                  }
                  
                  with open(OUTDIR / 'summary.json', 'w') as f:
                      json.dump(summary, f, indent=2)
                  
                  # Create simple README
                  with open(OUTDIR / 'README.md', 'w') as f:
                      f.write("# ðŸŽ¬ AI Director Output\n\n")
                      f.write(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n")
                      f.write(f"**Clips Created:** {created}\\n")
                      f.write(f"**Total Time:** {total_time:.1f}s\\n\\n")
                      
                      if created > 0:
                          f.write("## Generated Files:\\n")
                          for file in OUTDIR.glob("*.mp4"):
                              f.write(f"- `{file.name}`\\n")
                  
                  logger.info(f"ðŸŽ‰ Done! Created {created} clips in {total_time:.1f} seconds")
                  logger.info(f"ðŸ“ Output in: {OUTDIR}")
                  
              except Exception as e:
                  logger.error(f"âŒ Fatal error: {e}")
                  import traceback
                  logger.error(traceback.format_exc())
                  sys.exit(1)
          
          if __name__ == "__main__":
              main()
          EOF
          
          echo "ðŸš€ Running AI Director..."
          python ai_director_simple.py
          
      - name: ðŸ“¦ Package Output
        run: |
          echo "ðŸ“ Checking output..."
          
          if [ -d "output" ]; then
            echo "Output directory contents:"
            ls -la output/
            
            # Check if videos are playable
            if ls output/*.mp4 1> /dev/null 2>&1; then
              echo "âœ… MP4 files found, checking video info..."
              for f in output/*.mp4; do
                echo "Checking: $f"
                ffprobe -v error -show_format -show_streams "$f" 2>&1 | head -20
                echo "---"
              done
            fi
            
            # Create zip
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            zip -r "output_$TIMESTAMP.zip" output/
            echo "ðŸ“¦ Created: output_$TIMESTAMP.zip"
          else
            echo "âš ï¸ No output directory"
            mkdir -p output
            echo "No videos generated" > output/README.md
          fi
          
      - name: ðŸ“¤ Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ai-director-output
          path: |
            output/
            output_*.zip
            ai_director.log
          retention-days: 7
          if-no-files-found: warn
          
      - name: ðŸ“Š Generate Job Summary
        if: always()
        run: |
          echo "## ðŸŽ¬ AI Director Simple" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f "output/summary.json" ]; then
            echo "### ðŸ“Š Summary" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat output/summary.json >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -d "output" ] && ls output/*.mp4 1> /dev/null 2>&1; then
            echo "### ðŸŽ¥ Generated Videos" >> $GITHUB_STEP_SUMMARY
            for f in output/*.mp4; do
              size=$(stat -f%z "$f" 2>/dev/null || stat -c%s "$f" 2>/dev/null)
              echo "- **$(basename "$f")** ($((size/1024/1024)) MB)" >> $GITHUB_STEP_SUMMARY
            done
          fi
          
      - name: ðŸ§¹ Cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up..."
          rm -rf workspace/ || true
          rm -f ai_director_simple.py || true
          echo "âœ… Cleanup done"
