name: Run Viral Shorts Generator & Publish Zip

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]

permissions:
  contents: read

jobs:
  run-and-publish:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create viral_shorts.py
        run: |
          cat > viral_shorts.py <<'PY'
#!/usr/bin/env python3
'''
==============================================
AI VIRAL SHORTS GENERATOR - UNIVERSAL FLOW
==============================================
'''
import os
import sys
import json
import re
import subprocess
import traceback
import time
import gc
import shutil
from pathlib import Path
import warnings
warnings.filterwarnings('ignore')

print("Initializing AI Viral Shorts Generator...")

# ==================== CONFIGURATION ====================
class Config:
    def __init__(self):
        # API Config
        self.OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY", "Kontolondon")
        self.OPENAI_BASE_URL = "https://tes-coral.vercel.app/v1/"
        self.MODEL_NAME = "gpt-4"

        # Video Config
        self.MOBILE_WIDTH = 1080
        self.MOBILE_HEIGHT = 1920
        self.MIN_CLIP_DURATION = 5.0
        self.MAX_CLIP_DURATION = 60.0

        # Paths
        cwd = Path.cwd()
        self.WORK_DIR = cwd / "workspace"
        self.OUTPUT_DIR = cwd / "shorts_output"

        # TARGET VIDEO URL (FIXED)
        self.VIDEO_URL = "https://down-de.vidsyoutube.com/tmp/recycle/1m/content_site/download/9b/2c/8f9e9d2e47d15f075fefcc7d11eb9b2c-84617981.mp4?title=VIDI_BIKIN_ALBUM_BAHANNYA_APA_Video_diambil_terakhir_sblm_Hiatus_-_LOGIC_KAH_-_FRIMAWAN_480p.mp4"

        # Init Dirs
        self.WORK_DIR.mkdir(parents=True, exist_ok=True)
        self.OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

config = Config()

# ==================== HELPERS ====================
def clean_json(text):
    if not text: return None
    try:
        text = text.strip()
        if "```json" in text: text = text.split("```json", 1)[1].split("```", 1)[0]
        elif "```" in text: text = text.split("```")[1]
        return json.loads(text.strip())
    except:
        try: return json.loads(re.search(r'\{.*\}', text.replace('\n', ''), re.DOTALL).group())
        except: return None

# ==================== STEPS ====================
def step1_download():
    print(f"\n[1/7] DOWNLOADING VIDEO...")
    dest = config.WORK_DIR / "source_video.mp4"
    if dest.exists(): dest.unlink()
    
    # Method 1: Requests
    try:
        import requests
        print(f"   Downloading via requests: {config.VIDEO_URL[:60]}...")
        with requests.get(config.VIDEO_URL, stream=True, timeout=120) as r:
            r.raise_for_status()
            with open(dest, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192): f.write(chunk)
        if dest.exists() and dest.stat().st_size > 1024:
            print(f"   ‚úÖ Downloaded: {dest.stat().st_size/1024/1024:.2f} MB")
            return dest
    except Exception as e:
        print(f"   Requests failed: {e}")

    # Method 2: Curl
    try:
        print("   Trying curl...")
        subprocess.run(['curl', '-L', config.VIDEO_URL, '-o', str(dest)], check=True)
        if dest.exists(): return dest
    except: pass
    
    raise Exception("Failed to download video")

def step2_info(path):
    print(f"\n[2/7] GETTING VIDEO INFO...")
    duration = 0
    try:
        from moviepy.editor import VideoFileClip
        with VideoFileClip(str(path)) as clip: duration = clip.duration
    except:
        # Fallback ffmpeg
        try:
            res = subprocess.run(["ffprobe", "-v", "error", "-show_entries", "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", str(path)], capture_output=True, text=True)
            duration = float(res.stdout.strip())
        except: pass
    
    print(f"   Duration: {duration:.2f}s")
    return {"path": str(path), "duration": duration}

def step3_transcribe(video_path):
    print(f"\n[3/7] TRANSCRIBING...")
    try:
        import whisper
        import torch
        model = whisper.load_model("medium") # Use medium model
        
        # Extract audio first for speed
        audio_path = config.WORK_DIR / "audio.wav"
        subprocess.run(["ffmpeg", "-y", "-i", str(video_path), "-ar", "16000", "-ac", "1", "-c:a", "pcm_s16le", str(audio_path)], capture_output=True)
        
        result = model.transcribe(str(audio_path), fp16=torch.cuda.is_available())
        print(f"   Transcribed {len(result['text'])} chars")
        return result
    except Exception as e:
        print(f"   Transcription failed/skipped: {e}")
        return {"text": "", "segments": []}

def step4_analyze(transcript, duration):
    print(f"\n[4/7] AI ANALYSIS (Mocking strategy if API fails)...")
    candidates = []
    
    # Try AI Logic
    try:
        if config.OPENAI_API_KEY and len(transcript['text']) > 10:
            from langchain_openai import ChatOpenAI
            llm = ChatOpenAI(model=config.MODEL_NAME, openai_api_base=config.OPENAI_BASE_URL, api_key=config.OPENAI_API_KEY)
            prompt = f"Analyze this transcript from a {duration}s video. Find 3 viral clips (15-60s). Return JSON format: {{ 'clips': [ {{ 'start': 10, 'end': 30, 'title': 'Topic' }} ] }}. Transcript: {transcript['text'][:4000]}"
            res = llm.invoke(prompt)
            data = clean_json(res.content)
            if data and 'clips' in data:
                candidates = data['clips']
    except Exception as e:
        print(f"   AI Error: {e}")

    # Fallback Logic (Uniform cuts)
    if not candidates:
        print("   Using fallback cutting strategy")
        count = 3
        segment_len = min(45, duration / count)
        for i in range(count):
            start = 10 + (i * segment_len)
            if start + segment_len < duration:
                candidates.append({"start": start, "end": start + segment_len, "title": f"Highlight_Part_{i+1}"})
    
    return candidates

def step6_create_shorts(video_path, clips):
    print(f"\n[6/7] CREATING SHORTS...")
    created_files = []
    try:
        from moviepy.editor import VideoFileClip
        
        # Load video once
        video = VideoFileClip(str(video_path))
        
        for i, clip_data in enumerate(clips):
            try:
                start = float(clip_data.get('start', 0))
                end = float(clip_data.get('end', 0))
                title = re.sub(r'[^a-zA-Z0-9]', '_', clip_data.get('title', f'clip_{i}'))
                
                # Validation
                if end <= start: end = start + 15
                if end > video.duration: end = video.duration
                if (end - start) < 3: end = start + 10

                print(f"   Processing Clip {i+1}: {title} ({start:.1f}-{end:.1f})")
                
                # Cut
                sub = video.subclip(start, end)
                
                # Resize logic (Crop to 9:16)
                w, h = sub.size
                target_ratio = 9/16
                current_ratio = w/h
                
                if current_ratio > target_ratio:
                    # Crop width
                    new_width = int(h * target_ratio)
                    center_x = w // 2
                    sub = sub.crop(x1=center_x - new_width//2, width=new_width, height=h)
                
                # Resize to target
                final = sub.resize(height=config.MOBILE_HEIGHT)
                # Ensure even dimensions for ffmpeg
                if final.w % 2 != 0: final = final.resize(width=final.w - 1)
                
                filename = f"short_{i+1:02d}_{title}.mp4"
                out_path = config.OUTPUT_DIR / filename
                
                final.write_videofile(
                    str(out_path), 
                    codec='libx264', 
                    audio_codec='aac', 
                    fps=30, 
                    threads=4, 
                    preset='fast',
                    logger=None
                )
                
                created_files.append(filename)
                
                # Write Metadata
                with open(config.OUTPUT_DIR / f"{filename}.json", 'w') as f:
                    json.dump(clip_data, f, indent=2)
                    
            except Exception as e:
                print(f"   Failed clip {i}: {e}")
                traceback.print_exc()
            
            gc.collect()
            
        video.close()
        
    except Exception as e:
        print(f"   Video processing error: {e}")
        
    return created_files

def step7_zip():
    print(f"\n[7/7] ZIPPING OUTPUTS...")
    zip_name = "viral_shorts_package.zip"
    zip_path = Path.cwd() / zip_name
    
    import zipfile
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        # Add shorts
        for file in config.OUTPUT_DIR.glob("*"):
            zipf.write(file, arcname=f"shorts/{file.name}")
        # Add logs/info if exists
        if (config.WORK_DIR / "transcript.json").exists():
            zipf.write(config.WORK_DIR / "transcript.json", "transcript.json")
            
    print(f"   Zip created: {zip_path} ({zip_path.stat().st_size/1024/1024:.2f} MB)")
    return zip_path

# ==================== MAIN ====================
if __name__ == "__main__":
    try:
        video_path = step1_download()
        info = step2_info(video_path)
        transcript = step3_transcribe(video_path)
        clips = step4_analyze(transcript, info['duration'])
        files = step6_create_shorts(video_path, clips)
        step7_zip()
        print("\n‚úÖ PIPELINE COMPLETE")
    except Exception as e:
        print(f"\n‚ùå PIPELINE FAILED: {e}")
        traceback.print_exc()
        sys.exit(1)
PY

      - name: Make script executable
        run: chmod +x viral_shorts.py

      - name: Install system dependencies
        run: sudo apt-get update && sudo apt-get install -y ffmpeg

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          pip install --no-cache-dir --upgrade pip
          pip install --no-cache-dir moviepy requests openai-whisper langchain langchain-openai openai tiktoken numpy

      - name: Run Viral Shorts Generator
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: python viral_shorts.py

      - name: Upload Zip as Artifact
        id: upload-artifact
        uses: actions/upload-artifact@v4
        with:
          name: viral_shorts_package
          path: viral_shorts_package.zip
          retention-days: 5
          compression-level: 0 # File already zipped

      - name: üîó DISPLAY DOWNLOAD URL
        run: |
          echo "========================================================"
          echo "‚úÖ PROSES SELESAI"
          echo ""
          echo "‚¨áÔ∏è  LINK DOWNLOAD:"
          echo "üîó ${{ steps.upload-artifact.outputs.artifact-url }}"
          echo ""
          echo "‚ÑπÔ∏è  Note: Anda harus login ke GitHub untuk mendownload."
          echo "========================================================"
