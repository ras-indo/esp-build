name: Viral Video Editor CI/CD

on:
  workflow_dispatch:
    inputs:
      youtube_url:
        description: 'YouTube URL'
        required: true
        default: 'https://youtu.be/wn717YmB1z0' # Contoh default
      api_key:
        description: 'API Key (OpenAI)'
        required: true
        default: ''

jobs:
  process-video:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    # SETUP NODE.JS (PENTING untuk yt-dlp menangani signature/challenge)
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg
        # Install yt-dlp versi paling baru (wajib upgrade)
        pip install --upgrade yt-dlp faster-whisper numpy openai tqdm torch
        echo "‚úÖ Dependencies installed"
    
    - name: Run Video Editor Script
      env:
        API_KEY: ${{ github.event.inputs.api_key }}
        YOUTUBE_URL: ${{ github.event.inputs.youtube_url }}
      run: |
        # Create output directory
        mkdir -p output
        
        # WRITE PYTHON SCRIPT
        cat > video_editor.py << 'EOF'
        import os, sys, subprocess, json, time
        from pathlib import Path
        import torch
        from openai import OpenAI
        from faster_whisper import WhisperModel
        
        print("=" * 60)
        print("VIRAL VIDEO EDITOR - SMART DOWNLOADER EDITION")
        print("=" * 60)
        
        # ----------------------------
        # 1. SETUP & CONFIG
        # ----------------------------
        RAW_URL = os.getenv("YOUTUBE_URL", "").strip()
        API_KEY = os.getenv("API_KEY", "").strip()
        
        if not RAW_URL:
            print("‚ùå Error: URL Kosong!")
            sys.exit(1)

        # ----------------------------
        # 2. URL CLEANING (FIXED)
        # ----------------------------
        # Logic: Ambil bagian sebelum tanda tanya '?' untuk membuang ?si=...
        # Dan juga split '&' jaga-jaga format lama
        CLEAN_URL = RAW_URL.split('?')[0].split('&')[0]
        
        print(f"üîó Raw URL   : {RAW_URL}")
        print(f"‚ú® Clean URL : {CLEAN_URL}")
        
        OUTPUT_DIR = Path("./output")
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

        # ----------------------------
        # 3. SMART DOWNLOADER (RETRY LOGIC)
        # ----------------------------
        def download_with_retry(url, output_path="./video.mp4"):
            print(f"\nüì• DOWNLOADING VIDEO...")
            
            # Daftar strategi klien untuk mengelabui deteksi bot
            strategies = [
                {
                    "name": "Android Client (Mobile Spoofing)",
                    "args": ["--extractor-args", "youtube:player_client=android", "--user-agent", "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Mobile Safari/537.36"]
                },
                {
                    "name": "iOS Client (iPhone Spoofing)",
                    "args": ["--extractor-args", "youtube:player_client=ios"]
                },
                {
                    "name": "Web Client (Standard)",
                    "args": ["--user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"]
                }
            ]
            
            for strategy in strategies:
                print(f"   üîÑ Trying strategy: {strategy['name']}...")
                
                cmd = [
                    "yt-dlp",
                    "-f", "bv*[ext=mp4]+ba[ext=m4a]/b[ext=mp4] / bv*+ba/b",
                    "--force-overwrites",
                    "--no-playlist",
                    "-o", output_path
                ] + strategy['args'] + [url]
                
                try:
                    # Jalankan download
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    
                    # Cek keberhasilan
                    if result.returncode == 0 and Path(output_path).exists() and Path(output_path).stat().st_size > 1000:
                        size = Path(output_path).stat().st_size / (1024 * 1024)
                        print(f"   ‚úÖ SUCCESS! Downloaded ({size:.1f} MB)")
                        return Path(output_path)
                    else:
                        print(f"   ‚ö†Ô∏è Strategy failed. Error snippet: {result.stderr[:200]}...")
                        time.sleep(2) # Istirahat sebentar sebelum retry
                        continue
                        
                except Exception as e:
                    print(f"   ‚ö†Ô∏è Exception: {e}")
                    continue
            
            # Jika semua strategi gagal
            raise Exception("‚ùå All download strategies failed! YouTube is blocking the IP.")

        # ----------------------------
        # 4. PROCESSING PIPELINE
        # ----------------------------
        def process_video():
            try:
                # A. Download
                video_path = download_with_retry(CLEAN_URL)
                
                # B. Extract Audio
                print(f"\nüîä EXTRACTING AUDIO...")
                audio_path = Path("audio.wav")
                subprocess.run([
                    "ffmpeg", "-y", "-i", str(video_path),
                    "-vn", "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1",
                    "-loglevel", "error", str(audio_path)
                ], check=True)
                
                # C. Transcribe
                print(f"\nüéôÔ∏è TRANSCRIBING...")
                model = WhisperModel("tiny", device="cpu", compute_type="int8")
                segments_gen, _ = model.transcribe(str(audio_path))
                
                segments = []
                full_text = ""
                for s in segments_gen:
                    segments.append({"start": s.start, "end": s.end, "text": s.text.strip()})
                    full_text += s.text + " "
                
                print(f"   ‚úÖ Transcribed {len(segments)} segments")
                
                # D. GPT Analysis (Simple)
                clips = []
                if API_KEY:
                    print(f"\nüß† GPT ANALYSIS...")
                    try:
                        client = OpenAI(api_key=API_KEY, base_url="https://tes-coral.vercel.app/v1/")
                        prompt = f"""Task: Find 1 interesting part (15-50s) in this text.
                        Return JSON: [{{"start": 10, "end": 40, "title": "Viral Part"}}]
                        Text: {full_text[:3000]}"""
                        
                        resp = client.chat.completions.create(
                            model="gpt-4o", messages=[{"role": "user", "content": prompt}]
                        )
                        content = resp.choices[0].message.content
                        if "```" in content: content = content.split("```")[1].replace("json", "").strip()
                        clips = json.loads(content)
                    except Exception as e:
                        print(f"‚ö†Ô∏è GPT Error: {e}")
                
                # Fallback jika GPT gagal/tidak ada API
                if not clips:
                    print("‚ö†Ô∏è Using Fallback Clip (First 30s)")
                    clips = [{"start": 0, "end": 30, "title": "Intro Highlight"}]
                
                # E. Cutting
                print(f"\n‚úÇÔ∏è CUTTING VIDEO...")
                results = []
                for i, clip in enumerate(clips):
                    out_file = OUTPUT_DIR / f"clip_{i+1}.mp4"
                    subprocess.run([
                        "ffmpeg", "-y", "-i", str(video_path),
                        "-ss", str(clip['start']), "-to", str(clip['end']),
                        "-c:v", "libx264", "-preset", "ultrafast", "-c:a", "copy",
                        "-loglevel", "error", str(out_file)
                    ], check=True)
                    results.append(out_file)
                
                print(f"\n‚úÖ DONE! Created {len(results)} files in ./output")
                
                # ZIP Results
                import zipfile
                with zipfile.ZipFile("viral_segments.zip", "w") as z:
                    for f in results: z.write(f, f.name)

            except Exception as e:
                print(f"\n‚ùå FATAL ERROR: {e}")
                sys.exit(1)

        if __name__ == "__main__":
            process_video()
        EOF
        
        # RUN
        python video_editor.py
    
    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      if: success()
      with:
        name: viral-video-segments
        path: viral_segments.zip
        retention-days: 3
