name: Viral Video Editor CI/CD

on:
  workflow_dispatch:
    inputs:
      youtube_url:
        description: 'YouTube URL untuk diproses'
        required: true
        default: ''
      api_key:
        description: 'API Key untuk GPT-4'
        required: true
        default: ''

jobs:
  process-video:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg
        # Install yt-dlp via pip instead of apt for newer version
        echo "‚úÖ System dependencies installed"
    
    - name: Install Python dependencies
      run: |        
        pip install --upgrade yt-dlp
        pip install faster-whisper numpy openai tqdm torch
        echo "‚úÖ Python dependencies installed"
    
    - name: Run Video Editor Script
      env:
        API_KEY: ${{ github.event.inputs.api_key }}
        YOUTUBE_URL: ${{ github.event.inputs.youtube_url }}
      run: |
        echo "üöÄ Starting Viral Video Editor..."
        
        # Create output directory
        mkdir -p output
        
        # Create Python script file
        cat > video_editor.py << 'EOF'
        # ============================================================
        # VIRAL VIDEO EDITOR - FASTER-WHISPER + GPT-4
        # GitHub Actions Version (FIXED)
        # ============================================================
        import os, sys, subprocess, json, time, re, warnings
        from pathlib import Path
        import torch
        from openai import OpenAI
        from tqdm import tqdm
        import numpy as np
        
        print("=" * 60)
        print("VIRAL VIDEO EDITOR - GitHub Actions Edition")
        print("=" * 60)
        
        # ----------------------------
        # CONFIGURATION FROM ENVIRONMENT
        # ----------------------------
        # FIX: Tambahkan strip() untuk menghapus spasi tidak sengaja
        YOUTUBE_URL = os.getenv("YOUTUBE_URL", "").strip()
        API_KEY = os.getenv("API_KEY", "").strip()
        API_BASE = "https://tes-coral.vercel.app/v1/"
        WHISPER_MODEL_NAME = "medium" # Bisa ganti ke "tiny" atau "base" jika "medium" terlalu lambat/berat
        
        # FIX: Strict Validation
        if not YOUTUBE_URL or YOUTUBE_URL == "''" or len(YOUTUBE_URL) < 5:
            print("‚ùå Error: YOUTUBE_URL kosong atau tidak valid.")
            print("   Mohon masukkan URL saat menjalankan workflow.")
            sys.exit(1)
        
        if not API_KEY:
            print("‚ùå Error: API_KEY environment variable is required")
            sys.exit(1)
            
        print(f"üîó Target URL: {YOUTUBE_URL}")
        
        # Setup directories
        OUTPUT_DIR = Path("./output")
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
        AUDIO_PATH = Path("./audio.wav")
        VIDEO_PATH = Path("./video.mp4")
        
        # ----------------------------
        # INITIALIZE OPENAI CLIENT
        # ----------------------------
        try:
            openai_client = OpenAI(api_key=API_KEY, base_url=API_BASE)
            print("‚úÖ OpenAI client initialized")
        except Exception as e:
            print(f"‚ùå Failed to initialize OpenAI client: {e}")
            sys.exit(1)
        
        # ----------------------------
        # UTILITY FUNCTIONS
        # ----------------------------
        def download_youtube(url: str, output_path="./video.mp4") -> Path:
            print(f"\nüì• DOWNLOADING VIDEO FROM YOUTUBE")
            
            # FIX: Membersihkan URL dari parameter tracking
            clean_url = url.split('&')[0]
            print(f"   Clean URL: {clean_url}")
            
            # FIX: Opsi yt-dlp yang lebih robust untuk GitHub Actions
            cmd = [
               "yt-dlp",
                "-f", "bv*[ext=mp4]+ba[ext=m4a]/b[ext=mp4] / bv*+ba/b",
                "--force-overwrites",
                "--no-playlist",
                "--user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "-o", output_path,
                clean_url
            ]
            
            try:
                print("   üì¶ Downloading (Please wait)...")
                # Menggunakan check=True agar error langsung tertangkap
                subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                
                if Path(output_path).exists() and Path(output_path).stat().st_size > 0:
                    size = Path(output_path).stat().st_size / (1024 * 1024)
                    print(f"   ‚úÖ Download successful: {size:.1f} MB")
                    return Path(output_path)
                else:
                    raise Exception("File created but empty")
                    
            except subprocess.CalledProcessError as e:
                print(f"   ‚ùå yt-dlp Error Output:\n{e.stderr}")
                raise Exception(f"Download process failed with code {e.returncode}")
            except Exception as e:
                raise Exception(f"Download general failure: {str(e)}")
        
        def get_video_duration(path: Path) -> float:
            try:
                cmd = [
                    "ffprobe", "-v", "error",
                    "-show_entries", "format=duration",
                    "-of", "default=noprint_wrappers=1:nokey=1",
                    str(path)
                ]
                result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                return float(result.stdout.strip())
            except:
                return 0
        
        def convert_video_to_audio(video_path: Path, audio_path: Path) -> Path:
            print(f"\nüîÑ CONVERTING VIDEO TO AUDIO")
            
            cmd = [
                "ffmpeg",
                "-i", str(video_path),
                "-vn",
                "-acodec", "pcm_s16le",
                "-ar", "16000",
                "-ac", "1",
                "-y",
                "-loglevel", "error", # Reduce noise
                str(audio_path)
            ]
            
            try:
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0 and audio_path.exists():
                    print("   ‚úÖ Audio conversion successful")
                    return audio_path
                else:
                    print(result.stderr)
                    raise Exception("Audio conversion failed")
            except Exception as e:
                raise Exception(f"Audio conversion error: {str(e)}")
        
        # ----------------------------
        # FASTER-WHISPER TRANSCRIPTION
        # ----------------------------
        class FasterWhisperTranscriber:
            def __init__(self, model_name="medium"):
                self.model_name = model_name
                self.model = None
            
            def load_model(self):
                print(f"\nüì• LOADING FASTER-WHISPER MODEL ({self.model_name})")
                
                try:
                    from faster_whisper import WhisperModel
                    # Menggunakan int8 agar lebih hemat memory di GitHub Actions runner
                    self.model = WhisperModel(
                        self.model_name,
                        device="cpu",
                        compute_type="int8", 
                        download_root="./models"
                    )
                    print("   ‚úÖ Model loaded successfully")
                    return self.model
                except Exception as e:
                    print(f"   ‚ùå Failed to load model: {e}")
                    raise
            
            def transcribe(self, audio_path: Path):
                if not self.model:
                    self.load_model()
                
                print(f"\nüéôÔ∏è STARTING TRANSCRIPTION")
                
                try:
                    segments_generator, info = self.model.transcribe(
                        str(audio_path),
                        beam_size=5,
                        vad_filter=True,
                        vad_parameters=dict(min_silence_duration_ms=500)
                    )
                    
                    detected_language = info.language if hasattr(info, 'language') else "unknown"
                    print(f"   Detected language: {detected_language}")
                    
                    all_segments = []
                    full_text = ""
                    
                    for segment in segments_generator:
                        all_segments.append({
                            "start": segment.start,
                            "end": segment.end,
                            "text": segment.text.strip()
                        })
                        full_text += segment.text.strip() + " "
                    
                    result = {
                        "text": full_text.strip(),
                        "segments": all_segments,
                        "language": detected_language
                    }
                    
                    print(f"   ‚úÖ Transcription complete: {len(all_segments)} segments")
                    return result
                    
                except Exception as e:
                    raise Exception(f"Transcription failed: {str(e)}")
        
        # ----------------------------
        # GPT-4 EDITOR
        # ----------------------------
        class GPT4VideoEditor:
            def __init__(self, client, video_path: Path, transcript_data: dict):
                self.client = client
                self.video_path = video_path
                self.transcript = transcript_data
                self.duration = get_video_duration(video_path)
            
            def analyze_transcript(self):
                print(f"\nüß† ANALYZING WITH GPT-4")
                
                segments = self.transcript.get("segments", [])
                
                # Limit input to avoid context overflow / cost
                transcript_text = ""
                for seg in segments:
                    # Format: [0.0 - 5.0] Text
                    transcript_text += f"[{seg['start']:.1f}-{seg['end']:.1f}] {seg['text']}\n"
                
                # Truncate if too long (approx 8000 chars)
                if len(transcript_text) > 8000:
                    transcript_text = transcript_text[:8000] + "...(truncated)"
                
                system_prompt = """You are a viral video editor. Your job is to select the MOST ENGAGING parts of the video to turn into Shorts/Reels (under 60s)."""
                
                user_prompt = f"""Video Duration: {self.duration:.1f} seconds.
        
        Task: Identify 2-3 viral clips (max 60s each).
        Return purely JSON array format like:
        [
          {{"start_time": 10.5, "end_time": 45.2, "title": "Funny Moment", "hook": "Wait for it", "viral_reason": "Unexpected ending"}},
          ...
        ]
        
        Transcript:
        {transcript_text}
        """
                
                try:
                    response = self.client.chat.completions.create(
                        model="gpt-4o", # Menggunakan gpt-4o jika tersedia di endpoint Anda, atau gpt-4
                        messages=[
                            {"role": "system", "content": system_prompt},
                            {"role": "user", "content": user_prompt}
                        ],
                        temperature=0.7
                    )
                    
                    content = response.choices[0].message.content.strip()
                    # Clean markdown code blocks if present
                    if "```json" in content:
                        content = content.split("```json")[1].split("```")[0].strip()
                    elif "```" in content:
                        content = content.split("```")[1].split("```")[0].strip()
                        
                    return content
                    
                except Exception as e:
                    print(f"   ‚ùå GPT analysis failed: {e}")
                    return None
            
            def parse_segments(self, gpt_response: str):
                if not gpt_response:
                    return []
                
                try:
                    # Clean parsing
                    import json
                    segments = json.loads(gpt_response)
                    
                    validated = []
                    for i, seg in enumerate(segments, 1):
                        try:
                            start = float(seg["start_time"])
                            end = float(seg["end_time"])
                            duration = end - start
                            
                            # Validasi durasi logis
                            if 0 <= start < end <= self.duration and duration > 3 and duration <= 60:
                                validated.append({
                                    "index": i,
                                    "start_time": round(start, 2),
                                    "end_time": round(end, 2),
                                    "duration": round(duration, 2),
                                    "title": seg.get("title", f"Segment {i}"),
                                    "hook": seg.get("hook", ""),
                                    "viral_reason": seg.get("viral_reason", "")
                                })
                        except:
                            continue
                    
                    print(f"   ‚úÖ Parsed {len(validated)} valid segments")
                    return validated
                    
                except Exception as e:
                    print(f"   ‚ùå JSON Parse error: {e}")
                    print(f"   Raw response: {gpt_response}")
                    return []
        
        # ----------------------------
        # VIDEO CUTTER
        # ----------------------------
        def cut_segments(video_path: Path, segments: list, output_dir: Path):
            print(f"\n‚úÇÔ∏è CUTTING {len(segments)} SEGMENTS")
            
            results = []
            for seg in segments:
                idx = seg["index"]
                start = seg["start_time"]
                end = seg["end_time"]
                
                # Sanitize filename
                safe_title = re.sub(r'[^\w\s-]', '', seg["title"])
                safe_title = safe_title.strip().replace(" ", "_")[:30]
                output_file = output_dir / f"viral_{idx:02d}_{safe_title}.mp4"
                
                # Menggunakan re-encoding agar akurat
                cmd = [
                    "ffmpeg", "-y",
                    "-i", str(video_path),
                    "-ss", str(start),
                    "-to", str(end),
                    "-c:v", "libx264",
                    "-preset", "superfast", # Lebih cepat untuk CI/CD
                    "-crf", "23",
                    "-c:a", "aac",
                    "-b:a", "128k",
                    "-loglevel", "error",
                    str(output_file)
                ]
                
                try:
                    subprocess.run(cmd, check=True)
                    if output_file.exists():
                        size = output_file.stat().st_size / (1024 * 1024)
                        print(f"   ‚úÖ Created: {output_file.name} ({size:.1f} MB)")
                        
                        meta = seg.copy()
                        meta["filename"] = output_file.name
                        results.append(meta)
                except Exception as e:
                    print(f"   ‚ùå Failed to cut segment {idx}: {e}")
            
            return results
        
        # ----------------------------
        # MAIN EXECUTION
        # ----------------------------
        def main():
            print("\nüöÄ STARTING PROCESS")
            
            # 1. Download
            try:
                video_path = download_youtube(YOUTUBE_URL)
                duration = get_video_duration(video_path)
            except Exception as e:
                print(f"‚ùå Download/Duration Check Failed: {e}")
                sys.exit(1)
            
            # 2. Convert Audio
            try:
                audio_path = convert_video_to_audio(video_path, AUDIO_PATH)
            except Exception as e:
                print(f"‚ùå Audio Conversion Failed: {e}")
                sys.exit(1)
            
            # 3. Transcribe
            transcriber = FasterWhisperTranscriber(WHISPER_MODEL_NAME)
            try:
                result = transcriber.transcribe(audio_path)
            except Exception as e:
                print(f"‚ùå Transcription Failed: {e}")
                sys.exit(1)
            
            # 4. GPT Analysis
            editor = GPT4VideoEditor(openai_client, video_path, result)
            gpt_response = editor.analyze_transcript()
            
            segments = []
            if gpt_response:
                segments = editor.parse_segments(gpt_response)
            
            # Fallback jika GPT gagal atau return kosong
            if not segments:
                print("‚ö†Ô∏è  GPT did not return valid segments. Using Fallback Strategy.")
                segment_duration = 30
                if duration > segment_duration:
                    segments.append({
                        "index": 1,
                        "start_time": 0,
                        "end_time": segment_duration,
                        "title": "Intro Highlight",
                        "duration": segment_duration
                    })
                    
            if not segments:
                print("‚ùå No segments possible.")
                return
            
            # 5. Cut Video
            results = cut_segments(video_path, segments, OUTPUT_DIR)
            
            # 6. Final Report
            if results:
                print(f"\n‚úÖ PROCESSING COMPLETE!")
                print(f"   Created {len(results)} clips in {OUTPUT_DIR}")
                
                # Zip for easy download
                import zipfile
                with zipfile.ZipFile("viral_segments.zip", 'w', zipfile.ZIP_DEFLATED) as zf:
                    for file in OUTPUT_DIR.glob("*.mp4"):
                        zf.write(file, file.name)
            else:
                print("‚ùå Failed to create any video files.")
                sys.exit(1)
        
        if __name__ == "__main__":
            main()
        EOF
        
        # Run the script
        python video_editor.py
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      if: success()
      with:
        name: viral-video-segments
        path: |
          ./viral_segments.zip
        retention-days: 3
    
    - name: Clean up
      if: always()
      run: |
        echo "üßπ Cleaning up..."
        rm -f video.mp4 audio.wav
        rm -rf output
