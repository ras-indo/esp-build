
name: ðŸŽ¬ AI Director Ultra (Final Fix)

on:
  workflow_dispatch:
    inputs:
      video_url:
        description: 'URL Video MP4/YouTube'
        required: true
        default: 'https://api.vidssave.com/api/contentsite_api/media/download_redirect?request=sgRpmKL3iNBpyIDr4IgGHBXJiSxcf0EYQuGexs_6KdEalT5ycrs3ffYBEZXevrdUBcrNn6iDw8MfLNTFhlNy7biCIOWf4sDWWBA_S3Gc0ACg1ZPIBzwNN6iyUU-0-PuEErnV6vklMuUiHCyNARF0XKYdjAEXIFyrKF3ytFZL3SURwBQ6zqTIxoinSGmbNRzuDj7GLLN2-qE4j55wtrmuN0sRuMHC3v3eqf14UHFW6OQMmpQ5sIwzvVB6Y5OhROhLgjaA0g8XRTd1z8-rT37YaXo2Y1N59CFMiBNLYoMKlQY-ogHXajXJ3IPsDSTl679jtoOgZpQQY4lq8X-k8lRdgZ5x16iwKPU9AC5d20FwHAFwPaA6sqqj6Sulox0JtTHVQT3xcaUUJowztbrK3N1wClY_bp0pTnhFn4ntpiJhobshFeQwTW0cvTh7u-DnwrB6zF3N3uAfdG9YkBFZZfMIps_fqAN_JZe1TE8Xy6dOcm1cAkp4CQA-6VSb2h75I3aACfjLy872k1vGM7UyG_aS1MqWJUICirs_GRhll-ZswtvtiONJHwWROte6JB-8vU4YEOzzqQAnMb6vwwKFoFArv6XjRP9hX__3UF6yn8R7YYtp9bMuc53-ovjN9sdZoX02'
      num_shorts:
        description: 'Target Jumlah Klip'
        required: false
        default: '3'
      platform:
        description: 'Platform Target'
        required: false
        default: 'tiktok'
        type: choice
        options:
          - tiktok
          - youtube_shorts
          - instagram_reels
          - all
      quality:
        description: 'Kualitas Video'
        required: false
        default: 'balanced'
        type: choice
        options:
          - fast
          - balanced
          - high

jobs:
  ai-director-ultra:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    steps:
      - name: ðŸ“ Setup Workspace
        run: |
          mkdir -p workspace output logs
          
      - name: âš¡ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ðŸ Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: ðŸ”§ Install System Dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y \
            ffmpeg \
            libsm6 \
            libxext6 \
            libgl1 \
            git \
            wget \
            curl
          
      - name: ðŸ“¦ Install Python Packages (Stable Versions)
        run: |
          python -m pip install --upgrade pip
          
          # Install Whisper correctly
          pip install git+https://github.com/openai/whisper.git
          
          # PyTorch CPU version
          pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu
          
          # Core AI/ML - STABLE VERSIONS
          pip install openai==0.28.1  # Stable version without proxies issue
          pip install langchain==0.0.346  # Compatible version
          
          # Audio/Video Processing
          pip install yt-dlp==2024.4.9
          pip install ffmpeg-python==0.2.0
          
          # Utilities
          pip install numpy==1.26.4
          pip install tiktoken==0.5.2
          pip install tqdm==4.66.1
          pip install requests==2.31.0
          pip install colorama==0.4.6
          pip install tenacity==8.2.3
          
      - name: ðŸš€ Run AI Director Ultra (Fixed OpenAI)
        env:
          OPENAI_API_KEY: "Kontolondon"
          OPENAI_API_BASE: "https://tes-coral.vercel.app/v1/"
          VIDEO_URL: ${{ github.event.inputs.video_url }}
          NUM_SHORTS: ${{ github.event.inputs.num_shorts || 3 }}
          TARGET_PLATFORM: ${{ github.event.inputs.platform || 'tiktok' }}
          QUALITY_PRESET: ${{ github.event.inputs.quality || 'balanced' }}
        run: |
          cat > ai_director_final.py << 'EOF'
          import os
          import sys
          import json
          import re
          import subprocess
          import time
          import logging
          from pathlib import Path
          from datetime import datetime
          from typing import List, Dict, Any
          
          import whisper
          import torch
          from tqdm import tqdm
          
          # Setup logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.StreamHandler(),
                  logging.FileHandler('ai_director.log')
              ]
          )
          logger = logging.getLogger(__name__)
          
          # ========== CONFIGURATION ==========
          class Config:
              def __init__(self):
                  self.OPENAI_API_KEY = "Kontolondon"
                  self.OPENAI_API_BASE = "https://tes-coral.vercel.app/v1/"
                  self.GPT_MODEL = "gpt-4"
                  
                  self.VIDEO_URL = os.getenv("VIDEO_URL", "")
                  self.NUM_SHORTS = int(os.getenv("NUM_SHORTS", 3))
                  self.TARGET_PLATFORM = os.getenv("TARGET_PLATFORM", "tiktok")
                  self.QUALITY_PRESET = os.getenv("QUALITY_PRESET", "balanced")
                  
                  self.WORKDIR = Path("workspace")
                  self.OUTDIR = Path("output")
                  
                  self.WORKDIR.mkdir(exist_ok=True)
                  self.OUTDIR.mkdir(exist_ok=True)
                  
                  if not self.VIDEO_URL:
                      raise ValueError("VIDEO_URL is required!")
          
          config = Config()
          
          # ========== VIDEO DOWNLOADER ==========
          class VideoDownloader:
              def __init__(self):
                  self.video_path = config.WORKDIR / "source_video.mp4"
                  
              def download(self) -> Path:
                  """Download video with robust error handling"""
                  logger.info(f"ðŸ“¥ Downloading video from: {config.VIDEO_URL}")
                  
                  # Clean up any existing file
                  if self.video_path.exists():
                      self.video_path.unlink()
                  
                  try:
                      # Try yt-dlp first (best for YouTube-like URLs)
                      import yt_dlp
                      
                      ydl_opts = {
                          'format': 'best[ext=mp4]/best[ext=webm]/best',
                          'outtmpl': str(self.video_path.with_suffix('.%(ext)s')),
                          'quiet': True,
                          'no_warnings': True,
                          'extract_flat': False,
                          'http_headers': {
                              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                              'Accept': '*/*',
                              'Accept-Language': 'en-US,en;q=0.9',
                              'Referer': 'https://www.google.com/',
                              'Origin': 'https://vidssave.com'
                          },
                          'socket_timeout': 30,
                          'retries': 3
                      }
                      
                      with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                          # First, get info
                          try:
                              info = ydl.extract_info(config.VIDEO_URL, download=False)
                              if info:
                                  logger.info(f"ðŸŽ¬ Video found: {info.get('title', 'Unknown')}")
                                  logger.info(f"   Duration: {info.get('duration', 0)}s")
                          except:
                              logger.info("â„¹ï¸ Could not extract info, proceeding with download...")
                          
                          # Download the video
                          ydl.download([config.VIDEO_URL])
                      
                      # Find downloaded file
                      downloaded = None
                      for ext in ['.mp4', '.mkv', '.webm', '.mov']:
                          if self.video_path.with_suffix(ext).exists():
                              downloaded = self.video_path.with_suffix(ext)
                              logger.info(f"Found file: {downloaded}")
                              break
                      
                      if not downloaded:
                          # Try alternative download method
                          logger.warning("yt-dlp didn't save file, trying curl...")
                          self._download_with_curl()
                      else:
                          if downloaded.suffix != '.mp4':
                              # Convert to mp4
                              logger.info(f"Converting {downloaded.suffix} to mp4...")
                              subprocess.run([
                                  'ffmpeg', '-i', str(downloaded),
                                  '-c:v', 'copy', '-c:a', 'copy',
                                  str(self.video_path)
                              ], capture_output=True)
                              downloaded.unlink()
                          else:
                              self.video_path = downloaded
                      
                      # Validate the video
                      if self._validate_video():
                          size_mb = self.video_path.stat().st_size / (1024 * 1024)
                          logger.info(f"âœ… Download successful: {size_mb:.2f} MB")
                          return self.video_path
                      else:
                          raise ValueError("Downloaded file is not a valid video")
                          
                  except Exception as e:
                      logger.error(f"âŒ Download failed with yt-dlp: {e}")
                      # Fallback to curl
                      if self._download_with_curl():
                          return self.video_path
                      else:
                          raise
              
              def _download_with_curl(self) -> bool:
                  """Fallback download using curl"""
                  try:
                      logger.info("ðŸ”„ Trying curl download...")
                      
                      curl_cmd = [
                          'curl', '-L',
                          '-H', 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                          '-H', 'Accept: video/mp4,video/*;q=0.9,*/*;q=0.8',
                          '-H', 'Referer: https://vidssave.com',
                          '-H', 'Origin: https://vidssave.com',
                          '--compressed',
                          '--connect-timeout', '30',
                          '--max-time', '300',
                          '--retry', '3',
                          '--retry-delay', '2',
                          '-o', str(self.video_path),
                          config.VIDEO_URL
                      ]
                      
                      result = subprocess.run(
                          curl_cmd,
                          capture_output=True,
                          text=True,
                          timeout=300
                      )
                      
                      if result.returncode == 0:
                          if self._validate_video():
                              return True
                          else:
                              logger.error("Curl download failed validation")
                              return False
                      else:
                          logger.error(f"Curl failed: {result.stderr[:200]}")
                          return False
                          
                  except Exception as e:
                      logger.error(f"Curl download failed: {e}")
                      return False
              
              def _validate_video(self) -> bool:
                  """Validate downloaded video file"""
                  if not self.video_path.exists():
                      return False
                  
                  file_size = self.video_path.stat().st_size
                  if file_size < 1024 * 100:  # Less than 100KB
                      logger.error(f"File too small: {file_size} bytes")
                      return False
                  
                  # Try to check with ffprobe
                  try:
                      result = subprocess.run([
                          'ffprobe', '-v', 'error',
                          '-select_streams', 'v:0',
                          '-show_entries', 'stream=codec_type',
                          '-of', 'csv=p=0',
                          str(self.video_path)
                      ], capture_output=True, text=True, timeout=10)
                      
                      if result.returncode == 0 and 'video' in result.stdout:
                          return True
                  except:
                      pass
                  
                  # Fallback: check file extension and size
                  if file_size > 1024 * 1024:  # More than 1MB
                      return True
                  
                  return False
          
          # ========== AUDIO TRANSCRIBER ==========
          class AudioTranscriber:
              def __init__(self):
                  self.device = "cuda" if torch.cuda.is_available() else "cpu"
                  logger.info(f"Using device: {self.device}")
                  
              def transcribe(self, video_path: Path) -> List[Dict]:
                  """Transcribe audio using Whisper Medium"""
                  logger.info("ðŸŽ¤ Transcribing audio with Whisper Medium...")
                  
                  try:
                      model = whisper.load_model("medium")
                      
                      # Transcribe
                      result = model.transcribe(
                          str(video_path),
                          fp16=(self.device == "cuda"),
                          verbose=False,
                          language=None,
                          task="transcribe"
                      )
                      
                      segments = []
                      for seg in result.get("segments", []):
                          segments.append({
                              'start': float(seg['start']),
                              'end': float(seg['end']),
                              'text': seg['text'].strip(),
                              'duration': float(seg['end'] - seg['start'])
                          })
                      
                      logger.info(f"âœ… Transcription complete: {len(segments)} segments")
                      return segments
                      
                  except Exception as e:
                      logger.error(f"âŒ Transcription failed: {e}")
                      raise
          
          # ========== AI ANALYZER (Fixed OpenAI) ==========
          class AIAnalyzer:
              def __init__(self):
                  self.api_key = config.OPENAI_API_KEY
                  self.api_base = config.OPENAI_API_BASE
                  
              def analyze_segments(self, segments: List[Dict]) -> List[Dict]:
                  """Analyze segments using GPT-4 API directly (no LangChain)"""
                  logger.info("ðŸ§  Analyzing content with GPT-4...")
                  
                  # Prepare transcript
                  transcript = self._prepare_transcript(segments)
                  
                  # Create prompt
                  prompt = f"""
                  Anda adalah AI Director yang ahli dalam konten viral untuk TikTok.
                  
                  TUGAS: Pilih {config.NUM_SHORTS} klip terbaik dari transkrip video.
                  
                  TRANSCRIPT (dengan timestamp):
                  {transcript}
                  
                  KRITERIA PEMILIHAN:
                  1. HOOK KUAT: 5 detik pertama harus menarik perhatian
                  2. EMOSI TINGGI: Cari momen dengan emosi kuat (terkejut, senang, lucu, marah)
                  3. DURASI IDEAL: 8-15 detik untuk TikTok
                  4. CERITA LENGKAP: Ada awal, konflik/climax, dan kesimpulan
                  5. POTENSI VIRAL: Konten yang orang ingin bagikan
                  
                  INSTRUKSI:
                  - Pilih momen yang STANDALONE (bisa dipahami tanpa konteks)
                  - Hindari potongan kata di awal/akhir
                  - Prioritaskan konten yang relatable/universal
                  - Berikan judul yang clickbait dan menarik
                  
                  FORMAT OUTPUT (JSON array):
                  [
                    {{
                      "start_time": 45.2,
                      "end_time": 58.7,
                      "duration": 13.5,
                      "title": "Judul clickbait yang menarik",
                      "viral_score": 92,
                      "viral_reasons": ["emosi kuat", "hook menarik", "relatable"],
                      "hook_analysis": "Analisis mengapa 5 detik pertama menarik",
                      "target_audience": "Gen Z, usia 18-24",
                      "hashtags": ["#fyp", "#viral", "#trending"]
                    }}
                  ]
                  
                  Pastikan output HANYA JSON array, tanpa teks lain.
                  """
                  
                  try:
                      # Use OpenAI API directly (compatible version)
                      import openai
                      
                      # Configure OpenAI
                      openai.api_key = self.api_key
                      openai.api_base = self.api_base
                      
                      # Make API call
                      response = openai.ChatCompletion.create(
                          model="gpt-4",
                          messages=[
                              {"role": "system", "content": "You are a viral content AI director."},
                              {"role": "user", "content": prompt}
                          ],
                          temperature=0.3,
                          max_tokens=2000
                      )
                      
                      # Parse response
                      content = response.choices[0].message.content.strip()
                      logger.debug(f"GPT-4 Response: {content[:500]}...")
                      
                      # Extract JSON from response
                      json_match = re.search(r'\[.*\]', content, re.DOTALL)
                      if json_match:
                          clips = json.loads(json_match.group())
                      else:
                          # Try to parse directly
                          clips = json.loads(content)
                      
                      # Validate and enhance clips
                      valid_clips = []
                      for i, clip in enumerate(clips):
                          if self._validate_clip(clip):
                              clip['clip_id'] = f"clip_{i+1:03d}"
                              clip['platform'] = config.TARGET_PLATFORM
                              valid_clips.append(clip)
                      
                      logger.info(f"âœ… AI selected {len(valid_clips)} clips")
                      return valid_clips[:config.NUM_SHORTS]
                      
                  except json.JSONDecodeError as e:
                      logger.error(f"âŒ Failed to parse JSON from GPT-4: {e}")
                      logger.error(f"Response was: {content[:500]}")
                      return self._generate_fallback_clips(segments)
                      
                  except Exception as e:
                      logger.error(f"âŒ AI analysis failed: {e}")
                      return self._generate_fallback_clips(segments)
              
              def _prepare_transcript(self, segments: List[Dict]) -> str:
                  """Prepare transcript for AI analysis"""
                  transcript_lines = []
                  
                  for seg in segments[:50]:  # Limit to 50 segments
                      start_min = int(seg['start'] // 60)
                      start_sec = int(seg['start'] % 60)
                      text = seg['text'].strip()
                      
                      if text and len(text) > 3:
                          transcript_lines.append(
                              f"[{start_min:02d}:{start_sec:02d}] {text}"
                          )
                  
                  return "\n".join(transcript_lines)
              
              def _validate_clip(self, clip: Dict) -> bool:
                  """Validate clip structure"""
                  required = ['start_time', 'end_time', 'title']
                  for field in required:
                      if field not in clip:
                          logger.warning(f"Clip missing {field}")
                          return False
                  
                  try:
                      start = float(clip['start_time'])
                      end = float(clip['end_time'])
                      duration = end - start
                      
                      if start >= end:
                          return False
                      if duration < 5 or duration > 60:
                          return False
                          
                      # Add duration if not present
                      if 'duration' not in clip:
                          clip['duration'] = duration
                          
                  except (ValueError, TypeError):
                      return False
                  
                  return True
              
              def _generate_fallback_clips(self, segments: List[Dict]) -> List[Dict]:
                  """Generate fallback clips if AI fails"""
                  logger.warning("âš ï¸ Using fallback clip generation")
                  
                  clips = []
                  
                  if segments:
                      # Take segments at intervals
                      interval = max(1, len(segments) // config.NUM_SHORTS)
                      for i in range(min(config.NUM_SHORTS, 5)):
                          idx = min(i * interval, len(segments) - 1)
                          seg = segments[idx]
                          
                          start = seg['start']
                          end = min(start + 15, seg['end'] + 3)
                          
                          clips.append({
                              'clip_id': f"fallback_{i+1:03d}",
                              'start_time': start,
                              'end_time': end,
                              'duration': end - start,
                              'title': f"Viral Moment {i+1}",
                              'viral_score': 70 + (i * 5),
                              'viral_reasons': ['auto-generated', 'emotional'],
                              'hook_analysis': 'Automatically selected segment',
                              'hashtags': ['#fyp', '#viral', '#trending']
                          })
                  else:
                      # Create default clips
                      for i in range(min(config.NUM_SHORTS, 3)):
                          clips.append({
                              'clip_id': f"default_{i+1:03d}",
                              'start_time': i * 30,
                              'end_time': (i * 30) + 15,
                              'duration': 15,
                              'title': f"Highlight {i+1}",
                              'viral_score': 65,
                              'viral_reasons': ['default'],
                              'hashtags': ['#shorts', '#viral']
                          })
                  
                  return clips
          
          # ========== VIDEO PRODUCER ==========
          class VideoProducer:
              def __init__(self):
                  self.quality_presets = {
                      'fast': {'preset': 'ultrafast', 'crf': '28', 'bitrate': '1000k'},
                      'balanced': {'preset': 'fast', 'crf': '23', 'bitrate': '1500k'},
                      'high': {'preset': 'medium', 'crf': '20', 'bitrate': '2000k'}
                  }
                  
                  # Platform settings
                  self.platform_settings = {
                      'tiktok': {'resolution': '1080x1920', 'max_duration': 60},
                      'youtube_shorts': {'resolution': '1080x1920', 'max_duration': 60},
                      'instagram_reels': {'resolution': '1080x1920', 'max_duration': 90},
                      'all': {'resolution': '1080x1920', 'max_duration': 60}
                  }
              
              def produce_clips(self, video_path: Path, clips: List[Dict]) -> List[Dict]:
                  """Produce all video clips"""
                  logger.info(f"ðŸŽ¬ Producing {len(clips)} video clips...")
                  
                  produced_clips = []
                  platform_setting = self.platform_settings.get(
                      config.TARGET_PLATFORM, 
                      self.platform_settings['tiktok']
                  )
                  quality_setting = self.quality_presets.get(
                      config.QUALITY_PRESET,
                      self.quality_presets['balanced']
                  )
                  
                  for clip in clips:
                      try:
                          result = self._produce_single_clip(
                              video_path, clip, platform_setting, quality_setting
                          )
                          if result:
                              produced_clips.append(result)
                              logger.info(f"âœ… Created: {result['output_filename']}")
                      except Exception as e:
                          logger.error(f"âŒ Failed to create clip {clip.get('clip_id', 'unknown')}: {e}")
                  
                  logger.info(f"ðŸŽ‰ Successfully created {len(produced_clips)}/{len(clips)} clips")
                  return produced_clips
              
              def _produce_single_clip(self, video_path: Path, clip: Dict, 
                                     platform_setting: Dict, quality_setting: Dict) -> Dict:
                  """Produce a single video clip"""
                  try:
                      # Create safe filename
                      safe_title = self._sanitize_filename(clip['title'])
                      output_filename = f"{safe_title}_{clip['clip_id']}.mp4"
                      output_path = config.OUTDIR / output_filename
                      
                      # Get clip parameters
                      start = float(clip['start_time'])
                      duration = float(clip['duration'])
                      
                      # Ensure duration doesn't exceed platform limit
                      max_duration = platform_setting['max_duration']
                      if duration > max_duration:
                          duration = max_duration
                          clip['end_time'] = start + duration
                          clip['duration'] = duration
                      
                      # Build FFmpeg command
                      cmd = [
                          'ffmpeg', '-y',
                          '-ss', str(start),
                          '-i', str(video_path),
                          '-t', str(duration),
                          '-c:v', 'libx264',
                          '-preset', quality_setting['preset'],
                          '-crf', quality_setting['crf'],
                          '-b:v', quality_setting['bitrate'],
                          '-maxrate', quality_setting['bitrate'],
                          '-bufsize', '2000k',
                          '-c:a', 'aac',
                          '-b:a', '128k',
                          '-ar', '44100',
                          '-movflags', '+faststart',
                          '-vf', f"scale={platform_setting['resolution']}:force_original_aspect_ratio=increase,crop=iw:ih:0:0",
                          '-threads', '2',
                          str(output_path)
                      ]
                      
                      # Run FFmpeg
                      logger.debug(f"FFmpeg command: {' '.join(cmd)}")
                      
                      result = subprocess.run(
                          cmd,
                          capture_output=True,
                          text=True,
                          timeout=180
                      )
                      
                      if result.returncode != 0:
                          logger.error(f"FFmpeg error: {result.stderr[:300]}")
                          return None
                      
                      # Verify output
                      if not output_path.exists() or output_path.stat().st_size < 1024 * 100:
                          logger.error("Output file too small or doesn't exist")
                          return None
                      
                      # Update clip with file info
                      clip['output_filename'] = output_filename
                      clip['output_path'] = str(output_path)
                      clip['file_size_mb'] = output_path.stat().st_size / (1024 * 1024)
                      clip['created_at'] = datetime.now().isoformat()
                      
                      # Save metadata
                      metadata_path = output_path.with_suffix('.json')
                      with open(metadata_path, 'w', encoding='utf-8') as f:
                          json.dump(clip, f, indent=2, ensure_ascii=False)
                      
                      return clip
                      
                  except Exception as e:
                      logger.error(f"Clip production error: {e}")
                      return None
              
              def _sanitize_filename(self, filename: str) -> str:
                  """Sanitize filename for safety"""
                  # Remove problematic characters
                  sanitized = re.sub(r'[<>:"/\\|?*]', '', filename)
                  # Replace multiple spaces
                  sanitized = re.sub(r'\s+', '_', sanitized)
                  # Limit length
                  return sanitized[:50].strip('_')
          
          # ========== REPORT GENERATOR ==========
          class ReportGenerator:
              def generate(self, clips: List[Dict], processing_time: float):
                  """Generate comprehensive reports"""
                  logger.info("ðŸ“Š Generating production reports...")
                  
                  # Calculate statistics
                  total_duration = sum(c.get('duration', 0) for c in clips)
                  avg_viral_score = sum(c.get('viral_score', 0) for c in clips) / max(len(clips), 1)
                  total_size_mb = sum(c.get('file_size_mb', 0) for c in clips)
                  
                  # JSON Report
                  json_report = {
                      'generation_info': {
                          'timestamp': datetime.now().isoformat(),
                          'processing_time_seconds': round(processing_time, 2),
                          'platform': config.TARGET_PLATFORM,
                          'quality_preset': config.QUALITY_PRESET,
                          'num_clips_target': config.NUM_SHORTS,
                          'num_clips_produced': len(clips)
                      },
                      'statistics': {
                          'total_duration_seconds': round(total_duration, 2),
                          'average_duration_seconds': round(total_duration / max(len(clips), 1), 2),
                          'average_viral_score': round(avg_viral_score, 2),
                          'total_size_mb': round(total_size_mb, 2),
                          'average_size_mb': round(total_size_mb / max(len(clips), 1), 2)
                      },
                      'clips': clips
                  }
                  
                  # Save JSON report
                  json_path = config.OUTDIR / 'production_report.json'
                  with open(json_path, 'w', encoding='utf-8') as f:
                      json.dump(json_report, f, indent=2, ensure_ascii=False)
                  
                  # Generate Markdown summary
                  self._generate_markdown_summary(json_report)
                  
                  logger.info(f"âœ… Reports generated: {json_path}")
              
              def _generate_markdown_summary(self, report: Dict):
                  """Generate markdown summary for GitHub"""
                  md_path = config.OUTDIR / 'SUMMARY.md'
                  
                  with open(md_path, 'w', encoding='utf-8') as f:
                      f.write("# ðŸŽ¬ AI Director Ultra - Production Summary\n\n")
                      
                      # Overview
                      f.write("## ðŸ“‹ Overview\n")
                      f.write(f"- **Total Clips**: {report['generation_info']['num_clips_produced']}\n")
                      f.write(f"- **Platform**: {report['generation_info']['platform']}\n")
                      f.write(f"- **Quality**: {report['generation_info']['quality_preset']}\n")
                      f.write(f"- **Processing Time**: {report['generation_info']['processing_time_seconds']}s\n")
                      f.write(f"- **Average Viral Score**: {report['statistics']['average_viral_score']}/100\n\n")
                      
                      # Statistics
                      f.write("## ðŸ“Š Statistics\n")
                      f.write(f"- Total Duration: {report['statistics']['total_duration_seconds']}s\n")
                      f.write(f"- Average Duration: {report['statistics']['average_duration_seconds']}s\n")
                      f.write(f"- Total Size: {report['statistics']['total_size_mb']:.2f} MB\n")
                      f.write(f"- Average Size: {report['statistics']['average_size_mb']:.2f} MB\n\n")
                      
                      # Clips Table
                      f.write("## ðŸŽ¥ Generated Clips\n")
                      f.write("| No. | Title | Duration | Viral Score | Size |\n")
                      f.write("|-----|-------|----------|-------------|------|\n")
                      
                      for i, clip in enumerate(report['clips'], 1):
                          title = clip.get('title', 'Untitled')[:40]
                          if len(clip.get('title', '')) > 40:
                              title += "..."
                          
                          f.write(f"| {i} | {title} | ")
                          f.write(f"{clip.get('duration', 0):.1f}s | ")
                          f.write(f"{clip.get('viral_score', 0)} | ")
                          f.write(f"{clip.get('file_size_mb', 0):.1f}MB |\n")
                      
                      f.write("\n")
                      
                      # Recommendations
                      f.write("## ðŸ’¡ Posting Recommendations\n")
                      f.write("1. **Best Time to Post**: 7-9 PM local time\n")
                      f.write("2. **Hashtags**: Use 3-5 relevant hashtags\n")
                      f.write("3. **Engagement**: Reply to comments in first hour\n")
                      f.write("4. **Cross-Promote**: Share on other platforms\n")
                      f.write("5. **Consistency**: Post 1-2 times daily\n")
          
          # ========== MAIN EXECUTION ==========
          def main():
              """Main pipeline execution"""
              start_time = time.time()
              logger.info("ðŸš€ AI DIRECTOR ULTRA - STARTING PIPELINE")
              
              try:
                  # 1. DOWNLOAD VIDEO
                  logger.info("=" * 50)
                  logger.info("ðŸ“¥ STEP 1: Downloading video...")
                  downloader = VideoDownloader()
                  video_path = downloader.download()
                  
                  # 2. TRANSCRIBE AUDIO
                  logger.info("=" * 50)
                  logger.info("ðŸŽ¤ STEP 2: Transcribing audio...")
                  transcriber = AudioTranscriber()
                  segments = transcriber.transcribe(video_path)
                  
                  if not segments:
                      logger.error("âŒ No segments transcribed. Exiting.")
                      sys.exit(1)
                  
                  # 3. AI ANALYSIS
                  logger.info("=" * 50)
                  logger.info("ðŸ§  STEP 3: AI Analysis...")
                  analyzer = AIAnalyzer()
                  clips = analyzer.analyze_segments(segments)
                  
                  if not clips:
                      logger.error("âŒ No clips generated. Exiting.")
                      sys.exit(1)
                  
                  # 4. VIDEO PRODUCTION
                  logger.info("=" * 50)
                  logger.info("ðŸŽ¬ STEP 4: Video Production...")
                  producer = VideoProducer()
                  produced_clips = producer.produce_clips(video_path, clips)
                  
                  if not produced_clips:
                      logger.error("âŒ No clips produced. Exiting.")
                      sys.exit(1)
                  
                  # 5. GENERATE REPORTS
                  logger.info("=" * 50)
                  logger.info("ðŸ“Š STEP 5: Generating reports...")
                  processing_time = time.time() - start_time
                  report_gen = ReportGenerator()
                  report_gen.generate(produced_clips, processing_time)
                  
                  # SUCCESS MESSAGE
                  logger.info("=" * 50)
                  logger.info("ðŸŽ‰ PIPELINE COMPLETED SUCCESSFULLY!")
                  logger.info(f"ðŸ“ Output directory: {config.OUTDIR}")
                  logger.info(f"â±ï¸  Total time: {processing_time:.2f} seconds")
                  logger.info(f"ðŸŽ¬ Clips produced: {len(produced_clips)}")
                  logger.info("=" * 50)
                  
                  # List generated files
                  logger.info("ðŸ“„ Generated files:")
                  for file in config.OUTDIR.glob("*"):
                      if file.is_file():
                          size_mb = file.stat().st_size / (1024 * 1024)
                          logger.info(f"   - {file.name} ({size_mb:.2f} MB)")
                  
              except KeyboardInterrupt:
                  logger.info("âš ï¸ Pipeline interrupted by user")
                  sys.exit(130)
              except Exception as e:
                  logger.error(f"âŒ FATAL ERROR: {e}")
                  import traceback
                  logger.error(traceback.format_exc())
                  sys.exit(1)
          
          if __name__ == "__main__":
              main()
          EOF
          
          echo "ðŸš€ Running AI Director Ultra..."
          python ai_director_final.py
          
      - name: ðŸ“¦ Package Output
        run: |
          echo "ðŸ“ Checking output directory..."
          
          if [ -d "output" ] && [ "$(ls -A output/ 2>/dev/null)" ]; then
            echo "âœ… Output directory contains files:"
            ls -la output/
            
            # Create timestamped archive
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            zip -r "ai_director_output_$TIMESTAMP.zip" output/
            echo "ðŸ“¦ Created archive: ai_director_output_$TIMESTAMP.zip"
          else
            echo "âš ï¸ Output directory is empty or doesn't exist"
            # Create empty output directory
            mkdir -p output
            echo "No clips generated" > output/README.md
          fi
          
      - name: ðŸ“¤ Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ai-director-output
          path: |
            output/
            ai_director_output_*.zip
            ai_director.log
          retention-days: 7
          if-no-files-found: warn
          
      - name: ðŸ“Š Generate Job Summary
        if: always()
        run: |
          if [ -f "output/SUMMARY.md" ]; then
            echo "## ðŸŽ¬ AI Director Ultra - Production Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            cat output/SUMMARY.md >> $GITHUB_STEP_SUMMARY
          else
            echo "## ðŸŽ¬ AI Director Ultra" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Workflow completed. Check artifacts for output." >> $GITHUB_STEP_SUMMARY
            if [ -f "ai_director.log" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### Last 20 lines of log:" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              tail -20 ai_director.log >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "Log file empty" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
      - name: ðŸ§¹ Cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up workspace..."
          rm -rf workspace/ || true
          rm -f ai_director_final.py || true
          echo "âœ… Cleanup complete"
