name: Viral Video Editor CI/CD

on:
  workflow_dispatch:
    inputs:
      youtube_url:
        description: 'YouTube URL'
        required: true
        default: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'
      api_key:
        description: 'API Key (OpenAI)'
        required: true
        default: ''
      cookies_content:
        description: 'Isi Netscape Cookies (Opsional - Jika error bot berlanjut)'
        required: false
        default: ''

jobs:
  process-video:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    # FIX 1: Install Node.js untuk yt-dlp
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg
        echo "‚úÖ System dependencies installed"
    
    - name: Install Python dependencies
      run: |        
        # Install yt-dlp terbaru
        pip install --upgrade yt-dlp
        pip install faster-whisper numpy openai tqdm torch
        echo "‚úÖ Python dependencies installed"
        
    - name: Prepare Cookies (If Provided)
      env:
        COOKIES: ${{ github.event.inputs.cookies_content }}
      run: |
        if [ -n "$COOKIES" ]; then
          echo "$COOKIES" > cookies.txt
          echo "üç™ Cookies file created from input"
        else
          echo "‚ÑπÔ∏è No cookies provided, trying client spoofing method"
        fi

    - name: Run Video Editor Script
      env:
        API_KEY: ${{ github.event.inputs.api_key }}
        YOUTUBE_URL: ${{ github.event.inputs.youtube_url }}
      run: |
        echo "üöÄ Starting Viral Video Editor..."
        
        # Create output directory
        mkdir -p output
        
        # Create Python script file
        cat > video_editor.py << 'EOF'
        import os, sys, subprocess, json, time, re
        from pathlib import Path
        import torch
        from openai import OpenAI
        from tqdm import tqdm
        import numpy as np
        
        print("=" * 60)
        print("VIRAL VIDEO EDITOR - GitHub Actions Edition")
        print("=" * 60)
        
        # CONFIGURATION
        YOUTUBE_URL = os.getenv("YOUTUBE_URL", "").strip()
        API_KEY = os.getenv("API_KEY", "").strip()
        
        # Validasi URL
        if not YOUTUBE_URL or len(YOUTUBE_URL) < 5:
            print("‚ùå Error: YOUTUBE_URL wajib diisi!")
            sys.exit(1)
            
        print(f"üîó Target URL: {YOUTUBE_URL}")
        
        # Setup directories
        OUTPUT_DIR = Path("./output")
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
        
        # ----------------------------
        # 1. DOWNLOADER (FIXED FOR BOT DETECTION)
        # ----------------------------
        def download_youtube(url: str, output_path="./video.mp4") -> Path:
            print(f"\nüì• DOWNLOADING VIDEO...")
            
            clean_url = url.split('&')[0]
            
            # FIX: Teknik Anti-Bot Detection
            # Kita menyamar sebagai Android Client karena Web Client sering diblokir IP datacenter
            cmd = [
               "yt-dlp",
                "-f", "bv*[ext=mp4]+ba[ext=m4a]/b[ext=mp4] / bv*+ba/b",
                "--force-overwrites",
                "--no-playlist",
                # Menggunakan Android Client API (Lebih ramah untuk server IP)
                "--extractor-args", "youtube:player_client=android", 
                "--user-agent", "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Mobile Safari/537.36",
                "-o", output_path,
                clean_url
            ]
            
            # Gunakan cookies jika user memberikannya
            if os.path.exists("cookies.txt"):
                print("   üç™ Using provided cookies.txt")
                cmd.extend(["--cookies", "cookies.txt"])
            
            try:
                # Menjalankan command dan menangkap output real-time jika error
                result = subprocess.run(cmd, capture_output=True, text=True)
                
                if result.returncode == 0 and Path(output_path).exists() and Path(output_path).stat().st_size > 0:
                    size = Path(output_path).stat().st_size / (1024 * 1024)
                    print(f"   ‚úÖ Download successful: {size:.1f} MB")
                    return Path(output_path)
                else:
                    # Tampilkan error detail dari yt-dlp
                    print(f"‚ùå Download Failed. yt-dlp output:\n{result.stderr}")
                    raise Exception("yt-dlp execution failed")
                    
            except Exception as e:
                raise Exception(f"Download Error: {str(e)}")

        # ----------------------------
        # 2. AUDIO CONVERTER
        # ----------------------------
        def convert_to_audio(video_path):
            print(f"\nüîÑ EXTRACTING AUDIO")
            audio_path = Path("audio.wav")
            cmd = [
                "ffmpeg", "-y", "-i", str(video_path),
                "-vn", "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1",
                "-loglevel", "error", str(audio_path)
            ]
            subprocess.run(cmd, check=True)
            return audio_path

        # ----------------------------
        # 3. TRANSCRIBER & GPT (SIMPLIFIED)
        # ----------------------------
        def process_content(video_path):
            # A. Extract Audio
            audio_path = convert_to_audio(video_path)
            
            # B. Transcribe
            print("\nüéôÔ∏è TRANSCRIBING (Faster-Whisper)")
            from faster_whisper import WhisperModel
            model = WhisperModel("tiny", device="cpu", compute_type="int8") # Pakai 'tiny' biar cepat
            segments_gen, _ = model.transcribe(str(audio_path))
            
            segments = []
            text_full = ""
            for seg in segments_gen:
                segments.append({"start": seg.start, "end": seg.end, "text": seg.text.strip()})
                text_full += seg.text + " "
            
            print(f"   ‚úÖ Transcribed {len(segments)} lines")

            # C. GPT Analysis
            print("\nüß† GPT-4 ANALYSIS")
            client = OpenAI(api_key=API_KEY, base_url="https://tes-coral.vercel.app/v1/")
            
            prompt = f"""
            Identify 1 viral segment (15-60s) from this transcript.
            Return ONLY raw JSON: [{{"start": 10.5, "end": 40.2, "title": "Viral Clip"}}]
            
            Transcript: {text_full[:4000]}
            """
            
            try:
                resp = client.chat.completions.create(
                    model="gpt-4o",
                    messages=[{"role": "user", "content": prompt}]
                )
                content = resp.choices[0].message.content
                # Clean JSON code blocks
                if "```" in content: content = content.split("```")[1].replace("json", "").strip()
                cuts = json.loads(content)
                return cuts
            except Exception as e:
                print(f"‚ö†Ô∏è GPT Error: {e}. Using fallback.")
                # Fallback: Ambil 30 detik pertama
                return [{"start": 0, "end": 30, "title": "Highlight"}]

        # ----------------------------
        # 4. CUTTER
        # ----------------------------
        def cut_video(video_path, cuts):
            print(f"\n‚úÇÔ∏è CUTTING VIDEO")
            results = []
            for i, cut in enumerate(cuts):
                out_name = OUTPUT_DIR / f"clip_{i+1}.mp4"
                cmd = [
                    "ffmpeg", "-y", "-i", str(video_path),
                    "-ss", str(cut['start']), "-to", str(cut['end']),
                    "-c:v", "libx264", "-preset", "ultrafast", "-c:a", "copy",
                    "-loglevel", "error", str(out_name)
                ]
                subprocess.run(cmd)
                results.append(out_name)
            return results

        # ----------------------------
        # MAIN
        # ----------------------------
        if __name__ == "__main__":
            try:
                # 1. Download
                video_path = download_youtube(YOUTUBE_URL)
                
                # 2. Process
                cuts = process_content(video_path)
                
                # 3. Cut
                files = cut_video(video_path, cuts)
                
                print(f"\n‚úÖ DONE! Created {len(files)} clips.")
                
                # Zip results
                import zipfile
                with zipfile.ZipFile("viral_segments.zip", 'w') as z:
                    for f in files: z.write(f, f.name)
                    
            except Exception as e:
                print(f"\n‚ùå FATAL ERROR: {e}")
                sys.exit(1)
        EOF
        
        # Jalankan Script
        python video_editor.py
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      if: success()
      with:
        name: viral-video-segments
        path: viral_segments.zip
        retention-days: 3
