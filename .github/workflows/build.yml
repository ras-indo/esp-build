name: Viral Video Editor CI/CD

on:
  push:
    branches:
      - main
      - master

jobs:
  process-video:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    env:
      YOUTUBE_URL: "https://youtu.be/wVyu7NB7W6Y"
      WHISPER_MODEL_NAME: "medium"
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      OPENAI_API_BASE: ${{ secrets.OPENAI_API_BASE }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install system dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y ffmpeg git build-essential
          echo "âœ… System dependencies installed"

      - name: Install Python dependencies (CPU torch)
        run: |
          python -m pip install --upgrade pip
          # Prefer CPU wheel (faster & smaller on GitHub runners)
          pip install --index-url https://download.pytorch.org/whl/cpu torch || pip install torch
          pip install yt-dlp faster-whisper numpy openai tqdm
          echo "âœ… Python dependencies installed"

      - name: Run Video Editor Script
        env:
          YOUTUBE_URL: ${{ env.YOUTUBE_URL }}
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
          OPENAI_API_BASE: ${{ env.OPENAI_API_BASE }}
          WHISPER_MODEL_NAME: ${{ env.WHISPER_MODEL_NAME }}
        run: |
          echo "ðŸš€ Starting Viral Video Editor..."
          echo "YouTube URL: $YOUTUBE_URL"
          mkdir -p output

          cat > video_editor.py << 'PY'
#!/usr/bin/env python3
# Viral Video Editor (CI friendly)

import os, sys, subprocess, json, time, re
from pathlib import Path

YOUTUBE_URL = os.getenv("YOUTUBE_URL", "").strip()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()
OPENAI_API_BASE = os.getenv("OPENAI_API_BASE", "").strip() or None
WHISPER_MODEL_NAME = os.getenv("WHISPER_MODEL_NAME", "medium").strip()

OUTPUT_DIR = Path("./output")
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
VIDEO_PATH = Path("./video.mp4")
AUDIO_PATH = Path("./audio.wav")
ZIP_PATH = Path("./viral_segments.zip")

def run(cmd, timeout=None, check=False):
    print("RUN:", " ".join(map(str, cmd)))
    res = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
    if res.stdout:
        print(res.stdout)
    if res.stderr:
        print(res.stderr, file=sys.stderr)
    if check and res.returncode != 0:
        raise subprocess.CalledProcessError(res.returncode, cmd, res.stdout, res.stderr)
    return res

def download_youtube(url: str, output_path: str = str(VIDEO_PATH), attempts: int = 2):
    if not url:
        raise ValueError("YOUTUBE_URL required")
    cmd = [
        "yt-dlp",
        "-f", "bv*+ba/best",
        "--merge-output-format", "mp4",
        "--no-playlist",
        "--user-agent", "Mozilla/5.0",
        "-o", output_path,
        url
    ]
    last = None
    for i in range(attempts):
        try:
            print(f"Downloading attempt {i+1}")
            r = run(cmd, timeout=1200)
            if r.returncode == 0 and Path(output_path).exists():
                print("âœ… Download succeeded")
                return Path(output_path)
            last = r.stderr or r.stdout
        except Exception as e:
            last = str(e)
        time.sleep(2)
    raise Exception(f"Download failed after {attempts} attempts: {last}")

def convert_video_to_audio(video_path: Path, audio_path: Path):
    cmd = [
        "ffmpeg", "-y",
        "-i", str(video_path),
        "-vn",
        "-acodec", "pcm_s16le",
        "-ar", "16000",
        "-ac", "1",
        str(audio_path)
    ]
    run(cmd, timeout=300, check=True)
    if not audio_path.exists():
        raise Exception("Audio conversion failed")
    return audio_path

def get_video_duration(path: Path):
    try:
        r = run([
            "ffprobe", "-v", "error",
            "-show_entries", "format=duration",
            "-of", "default=noprint_wrappers=1:nokey=1",
            str(path)
        ], timeout=20)
        return float(r.stdout.strip() or 0.0)
    except Exception:
        return 0.0

def transcribe_with_faster_whisper(audio_path: Path, model_name: str):
    try:
        from faster_whisper import WhisperModel
    except Exception as e:
        raise Exception(f"Import failed: {e}")
    model = WhisperModel(model_name, device="cpu", compute_type="int8", download_root="./models")
    segments_gen, info = model.transcribe(str(audio_path), beam_size=5, vad_filter=True, vad_parameters=dict(min_silence_duration_ms=500))
    segments = []
    full = ""
    for s in segments_gen:
        segments.append({"start": s.start, "end": s.end, "text": s.text.strip()})
        full += s.text.strip() + " "
    return {"text": full.strip(), "segments": segments, "language": getattr(info, "language", "unknown")}

def main():
    print("START")
    try:
        video = download_youtube(YOUTUBE_URL)
    except Exception as e:
        print("Download failed:", e)
        sys.exit(1)

    duration = get_video_duration(VIDEO_PATH)
    print("Duration:", duration)

    try:
        audio = convert_video_to_audio(VIDEO_PATH, AUDIO_PATH)
    except Exception as e:
        print("Audio convert failed:", e)
        sys.exit(1)

    try:
        transcript = transcribe_with_faster_whisper(audio, WHISPER_MODEL_NAME)
        with open(OUTPUT_DIR / "transcript.json", "w", encoding="utf-8") as f:
            json.dump(transcript, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print("Transcription failed:", e)
        transcript = {"text": "", "segments": [], "language": "unknown"}

    # Simple fallback segments (no GPT)
    segments = []
    if duration > 30:
        segments.append({"index": 1, "start_time": 0.0, "end_time": min(30.0, duration), "duration": min(30.0, duration), "title": "First_30s"})
    if duration > 60:
        mid = duration / 2.0
        s = max(0.0, mid - 15.0)
        e = min(duration, mid + 15.0)
        segments.append({"index": 2, "start_time": round(s,2), "end_time": round(e,2), "duration": round(e-s,2), "title": "Middle_30s"})

    import zipfile
    with zipfile.ZipFile(str(ZIP_PATH), 'w', zipfile.ZIP_DEFLATED) as zf:
        for seg in segments:
            out = OUTPUT_DIR / f"seg_{seg['index']}.txt"
            out.write_text(str(seg))
            zf.write(out, out.name)

    print("DONE")

if __name__ == '__main__':
    main()
PY

          python3 video_editor.py

      - name: Upload artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: viral-video-segments
          path: |
            ./output/
            ./viral_segments.zip
          retention-days: 7

      - name: Clean up
        if: ${{ always() }}
        run: |
          echo "ðŸ§¹ Cleaning up..."
          rm -f video.mp4 audio.wav viral_segments.zip

      - name: Display summary
        if: ${{ always() }}
        run: |
          echo "âœ… Workflow completed (or exited). Check job logs and artifacts."
