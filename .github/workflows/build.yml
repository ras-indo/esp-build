name: Viral Video Editor CI/CD

on:
  workflow_dispatch:
    inputs:
      youtube_url:
        description: 'YouTube URL untuk diproses'
        required: true
        default: 'https://youtu.be/wVyu7NB7W6Y?si=-l7oIvGmke77pWYj'
      api_key:
        description: 'API Key untuk GPT-4'
        required: true
        default: ''

jobs:
  process-video:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg
        echo "‚úÖ System dependencies installed"
    
    - name: Install Python dependencies
      run: |
        pip install yt-dlp faster-whisper numpy openai tqdm torch
        echo "‚úÖ Python dependencies installed"
    
    - name: Run Video Editor Script
      env:
        API_KEY: ${{ github.event.inputs.api_key }}
        YOUTUBE_URL: ${{ github.event.inputs.youtube_url }}
      run: |
        echo "üöÄ Starting Viral Video Editor..."
        echo "YouTube URL: $YOUTUBE_URL"
        
        # Create output directory
        mkdir -p output
        
        # Create Python script file
        cat > video_editor.py << 'EOF'
        # ============================================================
        # VIRAL VIDEO EDITOR - FASTER-WHISPER + GPT-4
        # GitHub Actions Version
        # ============================================================
        import os, sys, subprocess, json, time, re, warnings
        from pathlib import Path
        import torch
        from openai import OpenAI
        from tqdm import tqdm
        import numpy as np
        
        print("=" * 60)
        print("VIRAL VIDEO EDITOR - GitHub Actions Edition")
        print("=" * 60)
        
        # ----------------------------
        # CONFIGURATION FROM ENVIRONMENT
        # ----------------------------
        YOUTUBE_URL = os.getenv("YOUTUBE_URL", "")
        API_KEY = os.getenv("API_KEY", "")
        API_BASE = "https://tes-coral.vercel.app/v1/"
        WHISPER_MODEL_NAME = "medium"
        
        if not YOUTUBE_URL:
            print("‚ùå Error: YOUTUBE_URL environment variable is required")
            sys.exit(1)
        
        if not API_KEY:
            print("‚ùå Error: API_KEY environment variable is required")
            sys.exit(1)
        
        # Setup directories
        OUTPUT_DIR = Path("./output")
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
        AUDIO_PATH = Path("./audio.wav")
        VIDEO_PATH = Path("./video.mp4")
        
        # ----------------------------
        # INITIALIZE OPENAI CLIENT
        # ----------------------------
        try:
            openai_client = OpenAI(api_key=API_KEY, base_url=API_BASE)
            print("‚úÖ OpenAI client initialized")
        except Exception as e:
            print(f"‚ùå Failed to initialize OpenAI client: {e}")
            sys.exit(1)
        
        # ----------------------------
        # UTILITY FUNCTIONS (Simplified)
        # ----------------------------
        def download_youtube(url: str, output_path="./video.mp4") -> Path:
            print(f"\nüì• DOWNLOADING VIDEO FROM YOUTUBE")
            print(f"   URL: {url}")
            
            clean_url = url.split('?')[0]
            
            cmd = [
                "yt-dlp",
                "-f", "best[height<=720][ext=mp4]/best[ext=mp4]/best",
                "-o", output_path,
                clean_url
            ]
            
            try:
                print("   üì¶ Downloading...")
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
                
                if result.returncode == 0 and Path(output_path).exists():
                    size = Path(output_path).stat().st_size / (1024 * 1024)
                    print(f"   ‚úÖ Download successful: {size:.1f} MB")
                    return Path(output_path)
                else:
                    raise Exception("Download failed")
                    
            except Exception as e:
                raise Exception(f"Download failed: {str(e)}")
        
        def get_video_duration(path: Path) -> float:
            try:
                cmd = [
                    "ffprobe", "-v", "error",
                    "-show_entries", "format=duration",
                    "-of", "default=noprint_wrappers=1:nokey=1",
                    str(path)
                ]
                result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                return float(result.stdout.strip())
            except:
                return 0
        
        def convert_video_to_audio(video_path: Path, audio_path: Path) -> Path:
            print(f"\nüîÑ CONVERTING VIDEO TO AUDIO")
            
            cmd = [
                "ffmpeg",
                "-i", str(video_path),
                "-vn",
                "-acodec", "pcm_s16le",
                "-ar", "16000",
                "-ac", "1",
                "-y",
                str(audio_path)
            ]
            
            try:
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0 and audio_path.exists():
                    print("   ‚úÖ Audio conversion successful")
                    return audio_path
                else:
                    raise Exception("Audio conversion failed")
            except Exception as e:
                raise Exception(f"Audio conversion error: {str(e)}")
        
        # ----------------------------
        # FASTER-WHISPER TRANSCRIPTION
        # ----------------------------
        class FasterWhisperTranscriber:
            def __init__(self, model_name="medium"):
                self.model_name = model_name
                self.model = None
            
            def load_model(self):
                print(f"\nüì• LOADING FASTER-WHISPER MODEL")
                
                try:
                    from faster_whisper import WhisperModel
                    
                    self.model = WhisperModel(
                        self.model_name,
                        device="cpu",
                        compute_type="int8",
                        download_root="./models"
                    )
                    print("   ‚úÖ Model loaded successfully")
                    return self.model
                except Exception as e:
                    print(f"   ‚ùå Failed to load model: {e}")
                    raise
            
            def transcribe(self, audio_path: Path):
                if not self.model:
                    self.load_model()
                
                print(f"\nüéôÔ∏è STARTING TRANSCRIPTION")
                
                try:
                    segments_generator, info = self.model.transcribe(
                        str(audio_path),
                        beam_size=5,
                        vad_filter=True,
                        vad_parameters=dict(min_silence_duration_ms=500)
                    )
                    
                    detected_language = info.language if hasattr(info, 'language') else "unknown"
                    print(f"   Detected language: {detected_language}")
                    
                    all_segments = []
                    full_text = ""
                    
                    for segment in segments_generator:
                        all_segments.append({
                            "start": segment.start,
                            "end": segment.end,
                            "text": segment.text.strip()
                        })
                        full_text += segment.text.strip() + " "
                    
                    result = {
                        "text": full_text.strip(),
                        "segments": all_segments,
                        "language": detected_language
                    }
                    
                    print(f"   ‚úÖ Transcription complete: {len(all_segments)} segments")
                    return result
                    
                except Exception as e:
                    raise Exception(f"Transcription failed: {str(e)}")
        
        # ----------------------------
        # GPT-4 EDITOR (Simplified)
        # ----------------------------
        class GPT4VideoEditor:
            def __init__(self, client, video_path: Path, transcript_data: dict):
                self.client = client
                self.video_path = video_path
                self.transcript = transcript_data
                self.duration = get_video_duration(video_path)
            
            def analyze_transcript(self):
                print(f"\nüß† ANALYZING WITH GPT-4")
                
                segments = self.transcript.get("segments", [])
                transcript_text = ""
                for i, seg in enumerate(segments[:30]):
                    transcript_text += f"[{seg['start']:.1f}s - {seg['end']:.1f}s]: {seg['text']}\n"
                
                system_prompt = """You are a professional video editor. Select viral segments under 60 seconds."""
                
                user_prompt = f"""Video Duration: {self.duration:.1f} seconds
        Segments: {len(segments)}
        
        Select 2-3 viral segments under 60 seconds each.
        
        Transcript:
        {transcript_text}
        
        Return JSON array with start_time, end_time, title."""
                
                try:
                    response = self.client.chat.completions.create(
                        model="gpt-4",
                        messages=[
                            {"role": "system", "content": system_prompt},
                            {"role": "user", "content": user_prompt}
                        ],
                        temperature=0.7,
                        max_tokens=1000
                    )
                    
                    return response.choices[0].message.content.strip()
                    
                except Exception as e:
                    print(f"   ‚ùå GPT-4 analysis failed: {e}")
                    return None
            
            def parse_segments(self, gpt_response: str):
                if not gpt_response:
                    return []
                
                try:
                    # Extract JSON
                    json_match = re.search(r'\[\s*\{.*\}\s*\]', gpt_response, re.DOTALL)
                    if json_match:
                        segments = json.loads(json_match.group(0))
                    else:
                        segments = []
                    
                    validated = []
                    for i, seg in enumerate(segments, 1):
                        try:
                            start = float(seg["start_time"])
                            end = float(seg["end_time"])
                            duration = end - start
                            
                            if 0 <= start < end <= self.duration and duration <= 60:
                                validated.append({
                                    "index": i,
                                    "start_time": round(start, 2),
                                    "end_time": round(end, 2),
                                    "duration": round(duration, 2),
                                    "title": seg.get("title", f"Segment {i}"),
                                    "hook": seg.get("hook", ""),
                                    "viral_reason": seg.get("viral_reason", "")
                                })
                        except:
                            continue
                    
                    print(f"   ‚úÖ Parsed {len(validated)} segments")
                    return validated
                    
                except Exception as e:
                    print(f"   ‚ùå Parse error: {e}")
                    return []
        
        # ----------------------------
        # VIDEO CUTTER
        # ----------------------------
        def cut_segments(video_path: Path, segments: list, output_dir: Path):
            print(f"\n‚úÇÔ∏è CUTTING {len(segments)} SEGMENTS")
            
            results = []
            for seg in segments:
                idx = seg["index"]
                start = seg["start_time"]
                end = seg["end_time"]
                
                safe_title = re.sub(r'[^\w\s-]', '', seg["title"])
                safe_title = safe_title.strip().replace(" ", "_")[:30]
                output_file = output_dir / f"segment_{idx:02d}_{safe_title}.mp4"
                
                cmd = [
                    "ffmpeg", "-y",
                    "-i", str(video_path),
                    "-ss", str(start),
                    "-to", str(end),
                    "-c:v", "libx264",
                    "-preset", "fast",
                    "-crf", "23",
                    "-c:a", "aac",
                    "-b:a", "128k",
                    str(output_file)
                ]
                
                try:
                    subprocess.run(cmd, capture_output=True, text=True)
                    if output_file.exists():
                        size = output_file.stat().st_size / (1024 * 1024)
                        print(f"   ‚úÖ Segment {idx}: {size:.1f} MB")
                        
                        # Save metadata
                        meta = seg.copy()
                        meta["output_file"] = output_file.name
                        meta["file_size_mb"] = round(size, 2)
                        
                        meta_file = output_file.with_suffix(".json")
                        with open(meta_file, "w") as f:
                            json.dump(meta, f, indent=2)
                        
                        results.append(meta)
                except:
                    print(f"   ‚ùå Failed segment {idx}")
            
            return results
        
        # ----------------------------
        # MAIN EXECUTION
        # ----------------------------
        def main():
            print("\nüöÄ STARTING PROCESS")
            
            # 1. Download video
            try:
                video_path = download_youtube(YOUTUBE_URL)
                duration = get_video_duration(video_path)
                print(f"   Duration: {duration:.1f} seconds")
                
                if duration == 0:
                    print("‚ùå Invalid video")
                    return
            except Exception as e:
                print(f"‚ùå Download failed: {e}")
                return
            
            # 2. Convert to audio
            try:
                audio_path = convert_video_to_audio(video_path, AUDIO_PATH)
            except Exception as e:
                print(f"‚ùå Audio conversion failed: {e}")
                return
            
            # 3. Transcribe
            transcriber = FasterWhisperTranscriber(WHISPER_MODEL_NAME)
            try:
                result = transcriber.transcribe(audio_path)
                
                # Save transcript
                transcript_file = OUTPUT_DIR / "transcript.json"
                with open(transcript_file, "w", encoding="utf-8") as f:
                    json.dump(result, f, ensure_ascii=False, indent=2)
                print(f"üíæ Transcript saved")
                
            except Exception as e:
                print(f"‚ùå Transcription failed: {e}")
                return
            
            # 4. GPT-4 Analysis
            editor = GPT4VideoEditor(openai_client, video_path, result)
            gpt_response = editor.analyze_transcript()
            
            if not gpt_response:
                print("‚ö†Ô∏è  Using fallback segments")
                # Create simple segments as fallback
                segments = []
                if duration > 30:
                    segments.append({
                        "index": 1,
                        "start_time": 0,
                        "end_time": min(30, duration),
                        "duration": min(30, duration),
                        "title": "First 30 Seconds",
                        "hook": "Watch this viral moment",
                        "viral_reason": "Opening segment"
                    })
                if duration > 60:
                    segments.append({
                        "index": 2,
                        "start_time": duration/2 - 15,
                        "end_time": duration/2 + 15,
                        "duration": 30,
                        "title": "Middle Segment",
                        "hook": "Best part in the middle",
                        "viral_reason": "Mid-video highlight"
                    })
            else:
                segments = editor.parse_segments(gpt_response)
            
            if not segments:
                print("‚ùå No segments created")
                return
            
            # 5. Cut segments
            results = cut_segments(video_path, segments, OUTPUT_DIR)
            
            # 6. Create summary
            if results:
                print(f"\n‚úÖ SUCCESS: Created {len(results)} segments")
                
                # Create README
                readme = OUTPUT_DIR / "README.txt"
                with open(readme, "w") as f:
                    f.write(f"Viral Video Segments\n")
                    f.write(f"====================\n\n")
                    f.write(f"Original Video: {YOUTUBE_URL}\n")
                    f.write(f"Duration: {duration:.1f} seconds\n")
                    f.write(f"Segments Created: {len(results)}\n\n")
                    
                    for res in results:
                        f.write(f"Segment {res['index']}:\n")
                        f.write(f"  File: {res['output_file']}\n")
                        f.write(f"  Time: {res['start_time']}s - {res['end_time']}s ({res['duration']}s)\n")
                        f.write(f"  Title: {res['title']}\n")
                        f.write(f"  Size: {res['file_size_mb']} MB\n\n")
                
                # Create zip
                import zipfile
                zip_path = Path("./viral_segments.zip")
                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for file_path in OUTPUT_DIR.glob("*"):
                        zipf.write(file_path, file_path.name)
                
                print(f"üì¶ Zip created: {zip_path}")
                print(f"üìÅ Output files in: {OUTPUT_DIR}")
                
                # List files
                print("\nüìÑ Generated files:")
                for file in sorted(OUTPUT_DIR.glob("*")):
                    if file.is_file():
                        size = file.stat().st_size / (1024 * 1024)
                        print(f"   {file.name} ({size:.1f} MB)")
            
            else:
                print("‚ùå No segments were created")
        
        if __name__ == "__main__":
            try:
                main()
            except Exception as e:
                print(f"\n‚ùå UNEXPECTED ERROR: {e}")
                import traceback
                traceback.print_exc()
        EOF
        
        # Run the script
        python video_editor.py
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: viral-video-segments
        path: |
          ./output/
          ./viral_segments.zip
        retention-days: 7
    
    - name: Clean up
      run: |
        echo "üßπ Cleaning up large temporary files..."
        rm -f video.mp4 audio.wav
        
    - name: Display summary
      run: |
        echo "‚úÖ Workflow completed!"
        echo "üì¶ Artifacts available for download:"
        echo "   - viral_segments.zip (all generated files)"
        echo "   - Individual files in the output folder"
